<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git之.git目录</title>
      <link href="/2025/01/22/Git%E4%B9%8B.git%E7%9B%AE%E5%BD%95/"/>
      <url>/2025/01/22/Git%E4%B9%8B.git%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><code>.git</code>目录是 Git 用来存储项目版本控制信息的核心目录，下面是<code>.git</code>目录中重要文件和文件夹的作用：</p><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p><code>HEAD</code>文件指向当前处于的分支。其内容通常为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/main</span><br></pre></td></tr></table></figure><p>这表明当前分支为<code>main</code>。</p><p>如果内容为<code>ref: refs/heads/feat</code>，表明当前分支为<code>feat</code></p><blockquote><p>Git 的设计是基于引用（refs）体系的，所有引用都存储在 .git&#x2F;refs 目录下，其中refs&#x2F;heads&#x2F; 用于存储分支</p></blockquote><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>存储对应项目的 Git 配置信息，例如远程仓库地址、体验化选项等。文件内容大致为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = false</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">        symlinks = false</span><br><span class="line">        ignorecase = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = https://github.com/xxx/xxx.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;main&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/main</span><br><span class="line">[branch &quot;feat1&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/feat1</span><br><span class="line">        vscode-merge-base = origin/main</span><br></pre></td></tr></table></figure><h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2><p>GitWeb 服务中用于显示项目描述，通常在本地使用时没有实际作用。</p><h2 id="objects"><a href="#objects" class="headerlink" title="objects&#x2F;"></a>objects&#x2F;</h2><p>Git 中最重要的文件夹，存储所有对象（如 commit 、tree 、blob，以及annotated tag）。不同对象根据对象的标识码和数据内容保存。</p><p>Git 中的所有对象（commit、tree、blob 和 annotated tag）在存储时都会经过以下两步处理：</p><ul><li>添加头部信息：包括对象类型和内容长度；</li><li>使用 zlib 压缩：将对象压缩为二进制格式存储。</li></ul><p>想要查看对象存储的信息可以使用命令<code>git cat-file -p &lt;hash-id&gt;</code></p><h3 id="Commit-对象"><a href="#Commit-对象" class="headerlink" title="Commit 对象"></a>Commit 对象</h3><p>记录一次提交操作，包含提交描述信息和对应根目录的 tree 对象。<strong>文件内容</strong>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tree &lt;tree-hash&gt;</span><br><span class="line">parent &lt;parent-hash&gt; # 可能有多个</span><br><span class="line">author &lt;author-name&gt; &lt;email&gt; &lt;timestamp&gt;</span><br><span class="line">committer &lt;committer-name&gt; &lt;email&gt; &lt;timestamp&gt;</span><br><span class="line"></span><br><span class="line">&lt;commit-message&gt;</span><br></pre></td></tr></table></figure><ul><li><code>tree-hash</code>：指向根目录的 tree 对象。</li><li><code>parent-hash</code>：指向上一个提交的哈希值（如果有多个父提交，则记录多个）。</li><li><code>author</code>：提交作者的信息，包括名字、邮箱和时间戳。</li><li><code>committer</code>：实际提交人信息（可能与作者不同）。</li><li><code>&lt;commit-message&gt;</code>：提交的描述信息。</li></ul><h3 id="Tree-对象"><a href="#Tree-对象" class="headerlink" title="Tree 对象"></a>Tree 对象</h3><p>存储目录中文件和子目录的结构信息，相当于一个目录的实时展示。<strong>文件内容</strong>：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;file-mode&gt; &lt;type&gt; &lt;hash&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure></p><ul><li><code>file-mode</code>：文件的权限信息（如普通文件、可执行文件、子目录等）。</li><li><code>type</code>：对象类型（blob 或 tree）。</li><li><code>hash</code>：对应 blob 或子 tree 对象的标识码。</li><li><code>filename</code>：文件或目录的名称。<br>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100644 blob 789abcd file.txt</span><br><span class="line">040000 tree 123efgh subdir</span><br></pre></td></tr></table></figure></li></ul><h3 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h3><p>存储文件的内容，没有文件名称或目录结构信息，是 Git 存储原始文件数据的核心实体。</p><p><strong>文件内容</strong>：直接存储文件内容（存储时经过<strong>添加头部</strong>和<strong>zlib压缩</strong>，故不是明文），不包含元数据。</p><ul><li>例如，一个文本文件 <code>hello.txt</code>，内容为 <code>Hello, world!</code>，其 blob 对象使用<code>git cat-file -p</code>查看后显示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></li></ul><h3 id="Annotated-Tag-对象"><a href="#Annotated-Tag-对象" class="headerlink" title="Annotated Tag 对象"></a>Annotated Tag 对象</h3><p>标记一个实体对象，通常用于永久标记，包含创建者、时间和描述信息。<strong>文件内容</strong>：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object &lt;object-hash&gt;</span><br><span class="line">type &lt;type&gt;</span><br><span class="line">tag &lt;tag-name&gt;</span><br><span class="line">tagger &lt;tagger-name&gt; &lt;email&gt; &lt;timestamp&gt;</span><br><span class="line"></span><br><span class="line">&lt;tag-message&gt;</span><br></pre></td></tr></table></figure></p><ul><li><code>object-hash</code>：指向被标记对象（如 commit）的哈希值。</li><li><code>type</code>：对象的类型（如 commit、tree、blob）。</li><li><code>tag-name</code>：标签的名称。</li><li><code>tagger</code>：标签创建者的信息。</li><li><code>&lt;tag-message&gt;</code>：标签的描述信息。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object f3a23bc4f1e8e5a1d07e8f5f0f7c12ef8f7d1234</span><br><span class="line">type commit</span><br><span class="line">tag v1.0</span><br><span class="line">tagger John Doe &lt;johndoe@example.com&gt; 1672531200 +0000</span><br><span class="line"></span><br><span class="line">Initial release</span><br></pre></td></tr></table></figure><p>这些对象是 Git 存储和追踪文件历史的核心，采用哈希值（<strong>SHA-1</strong> 或其他算法）唯一标识，确保了数据完整性和高效性。</p><h2 id="refs"><a href="#refs" class="headerlink" title="refs&#x2F;"></a>refs&#x2F;</h2><p>存放分支和标签信息，这些参照指向对应的 commit。包括三个个重要存储目录：</p><ul><li><code>refs/heads/</code>：存放分支信息；<ul><li><code>refs/heads/xxx</code>：<code>xxx</code>为本地分支名，其文件中存储该分支最新提交的hash id</li></ul></li><li><code>refs/remote/origin/</code>：存放远程分支信息<ul><li><code>refs/heads/xxx</code>：<code>xxx</code>为远程分支名，其文件中存储该分支最新提交的hash id</li></ul></li><li><code>refs/tags/</code>：存放标签信息。<ul><li><code>refs/tags/xxx</code>：<code>xxx</code>为附注标签名，其文件中存储该Annotated Tag的hash id</li></ul></li></ul><h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks&#x2F;"></a>hooks&#x2F;</h2><p>存放各种钩子脚本，用于在 Git 操作时执行自定义操作。其中.sample后缀的文件只是样例，需要将后缀去除并<strong>赋予执行权限</strong>后才能作为真正的脚本。脚本编写可以使用任何支持的脚本语言，如 Bash、Python 等</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls hooks</span><br><span class="line">applypatch-msg.sample      pre-applypatch.sample    pre-rebase.sample          sendemail-validate.sample</span><br><span class="line">commit-msg.sample          pre-commit.sample        pre-receive.sample         update.sample</span><br><span class="line">fsmonitor-watchman.sample  pre-merge-commit.sample  prepare-commit-msg.sample</span><br><span class="line">post-update.sample         pre-push.sample          push-to-checkout.sample</span><br></pre></td></tr></table></figure><p>例子：检查提交信息格式（commit-msg），确保提交信息以特定前缀开头</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Validating commit message...&quot;</span></span><br><span class="line"></span><br><span class="line">COMMIT_MSG=$(<span class="built_in">cat</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> [[ ! <span class="variable">$COMMIT_MSG</span> =~ ^(feat|fix|docs|style|refactor|<span class="built_in">test</span>|chore): ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Invalid commit message. Must start with one of: feat|fix|docs|style|refactor|test|chore.&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Commit message is valid.&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><blockquote><p>Hooks 不会随仓库一起推送到远程服务器。推荐将 Hooks 脚本存储在项目目录（如 .githooks&#x2F;）中，并通过文档指导团队成员启用。</p></blockquote><h3 id="info"><a href="#info" class="headerlink" title="info&#x2F;"></a>info&#x2F;</h3><p>包含额外的配置信息，例如<code>exclude</code>文件，设置本地排除要求。</p><h3 id="logs"><a href="#logs" class="headerlink" title="logs&#x2F;"></a>logs&#x2F;</h3><p>记录分支和<code>HEAD</code>的历史变化记录，便于优化和借助调试。</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>Git 的 <strong>暂存区</strong>（staging area）的核心数据结构，用于管理文件的快照。它记录了工作区中文件的状态信息，是 Git 的暂存操作、差异计算以及提交生成的关键组件，是一个二进制文件。</p><h3 id="packed-refs"><a href="#packed-refs" class="headerlink" title="packed-refs"></a>packed-refs</h3><p>将亚气式存储的参照（如分支）压缩为单个文件，减少文件总数，提高性能。</p><h3 id="COMMIT-EDITMSG"><a href="#COMMIT-EDITMSG" class="headerlink" title="COMMIT_EDITMSG"></a>COMMIT_EDITMSG</h3><p>存储最近一次 commit 的消息，便于检查和修改。</p><h3 id="ORIG-HEAD"><a href="#ORIG-HEAD" class="headerlink" title="ORIG_HEAD"></a>ORIG_HEAD</h3><p>记录最近一次重覆或结合之前的 HEAD 位置，通常用于撤销操作。</p><p>理解<code>.git</code>目录中各文件和文件夹的作用，能让我们更深入了解 Git 运作机制，并能在工作中更好地排查问题和优化流程。对于初学者，探索<code>.git</code>目录中的内容是学习 Git 的重要一步；对于高级用户，理解该目录能让你更好地自定义 Git 操作和优化项目管理。</p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tool </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git之基本用法(2)</title>
      <link href="/2025/01/20/Git%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(2)/"/>
      <url>/2025/01/20/Git%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(2)/</url>
      
        <content type="html"><![CDATA[<p>在<a href="https://dopaminenone.github.io/2025/01/08/Git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">Git基本用法</a>中，我们介绍了<strong>工作区</strong>，<strong>暂存区</strong>，<strong>版本库</strong>等概念，并介绍了本地git仓库中<strong>文件的各种状态</strong>，以及添加<strong>修改、创建提交</strong>以及相关的<strong>撤回</strong>的命令。接下来我们将继续介绍git的基本用法</p><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>分支是Git中的一个重要概念，实际研发流程就是紧密依赖不同分支实现的。分支本质上是指向一系列提交的指针。它允许你从开发主线分离出来，在不影响主分支的情况下进行独立的开发工作。</p><h3 id="分支改名"><a href="#分支改名" class="headerlink" title="分支改名"></a>分支改名</h3><p>我们在本地<code>git init</code>创建了一个本地仓库后，默认的主分支名是master。而为了避免敏感词汇，如今我们更推荐将主分支命名为main，因此我们可以使用命令<code>git branch -M</code>对当前分支进行改名：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -M main</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>有两种创建分支的方式：</p><ul><li>使用<code>git branch &lt;branch-name&gt;</code>命令可以以当前分支为起点，创建一个分支</li><li>使用<code>git checkout -b &lt;branch-name&gt;</code>可以以当前分支为起点，创建并跳转到新的分支</li></ul><p>这里以创建分支<code>feat/feat1</code>为例：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch feat/feat1</span><br></pre></td></tr></table></figure><h3 id="跳转分支"><a href="#跳转分支" class="headerlink" title="跳转分支"></a>跳转分支</h3><p>使用<code>git switch &lt;branch&gt;</code>或<code>git checkout &lt;branch&gt;</code>命令实现分支跳转</p><h3 id="临时保存分支修改"><a href="#临时保存分支修改" class="headerlink" title="临时保存分支修改"></a>临时保存分支修改</h3><p>如果目前在当前分支上已经有了一些<strong>未提交</strong>的修改，这时有一个紧急的 bug 需要在 main 分支上修复，就必须将当前修改进行保存</p><p>使用 <code>git stash</code> 命令将修改保存到 stash 栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>这会将工作目录和暂存区的修改保存起来，并将工作目录和暂存区恢复到最近一次提交的状态。</p><p>使用 <code>git stash list</code> 命令查看 stash 栈中的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>  它会列出所有存储在 stash 栈中的修改，每个存储都有一个唯一的标识符，如 <code>stash@&#123;0&#125;</code>、<code>stash@&#123;1&#125;</code> 等。</p><p>使用 <code>git stash apply</code> 命令将最近一次存储的修改应用到当前工作目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure><p>如果你想应用特定的 stash 项，可以使用 <code>git stash apply stash@&#123;n&#125;</code>，其中 <code>n</code> 是 stash 项的索引。</p><p>应用 stash 时，修改会被应用到工作目录，但不会从 stash 栈中删除。如果要同时删除 stash 项，可以使用 <code>git stash pop</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>它会将最近一次存储的修改应用到工作目录并从 stash 栈中删除。</p><p>可以使用 <code>git stash save &quot;message&quot;</code> 命令为 stash 保存添加描述信息，以便更好地识别 stash 中的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save &quot;Working on new feature, not completed yet&quot;</span><br></pre></td></tr></table></figure><p>使用 <code>git stash clear</code> 命令可以清空 stash 栈中的所有存储：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>合并分支也有两种方式：</p><ul><li><code>git merge</code> 会创建一个新的合并提交，将两个分支的修改合并在一起</li><li><code>git rebase</code> 会将一个分支上的提交移到另一个分支的末尾，让提交历史看起来是线性的。</li></ul><p>比如我们在<code>feat/feat1</code>上有了新的提交之后，就可以尝试将该分支与主分支main合并:</p><p>git merge:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(main)$ git merge feat/feat1</span><br></pre></td></tr></table></figure><p>或git rebase:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(feat/feat1)$ git rebase main</span><br></pre></td></tr></table></figure><p>如果两个分支对同一文件有不同的修改，就会产生冲突，这时就需要手动解决冲突后<code>git add .</code>提交修复后的内容，再使用<code>git merge --continue</code>或<code>git rebase --continue</code>，或者使用<code>--abort</code>放弃合并</p><blockquote><p>Git中合并分支的方式主要有两种：Fast-forward合并和Three Way Merge合并：</p><ol><li>Fast-forward：当试图将一个分支合并到另一个分支时，如果要合并的分支（源分支）是当前分支（目标分支）的直接后继，即要合并的分支是从当前分支直接分出去的，并且在源分支创建之后，当前分支没有新的提交，那么 Git 会使用 fast-forward 合并，即Git 会直接将源分支的指针向前移动（快进）到目标分支的最新提交</li><li>Three Way Merge：当试图将一个分支合并到另一个分支时，要合并的分支（源分支）是从当前分支（目标分支）直接分出去的，并且在源分支创建之后，当前分支有新的提交，那么Git会使用three-way-merge合并：如果两个分支见存在冲突，需要先解决冲突并将修改加入暂存区，然后进行合并后git会提交一个**合并提交(merge commit)**，而这个合并提交有两个父提交，分别来自合并的两个分支，详情可见<a href="">git之.git目录详解</a>中object的介绍。最新版本中git使用Ort策略实现Three Way Merge。</li></ol></blockquote><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><p>Git 中的 tag 是一个指向某个特定提交的引用，通常用于标记项目中的重要版本或里程碑。它类似于一个分支，但不同的是，分支可以随着新的提交而移动，而 tag 是一个静态的指针，它会一直指向特定的提交，不会随着新的提交而改变。</p><p>git tag又分为<strong>轻量级tag</strong>和<strong>附注tag</strong>，前者只是一个指向提交的指针，不包含额外的信息，后者包含更多信息，如创建者、创建日期、标签信息等。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 轻量级</span><br><span class="line">git tag &lt;tag_name&gt;</span><br><span class="line"></span><br><span class="line"># 附注</span><br><span class="line">git tag -a &lt;tag_name&gt; -m &quot;tag message&quot;</span><br><span class="line"></span><br><span class="line"># 删除本地标签</span><br><span class="line">git tag -d &lt;tag_name&gt;</span><br></pre></td></tr></table></figure><blockquote><p>附注标签还会对应一个tag object（轻量级标签没有），详情见<a href="">git之.git目录详解</a>中对object的介绍</p></blockquote><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><h3 id="绑定远程仓库"><a href="#绑定远程仓库" class="headerlink" title="绑定远程仓库"></a>绑定远程仓库</h3><p>通过<code>git remote add</code>命令绑定远程仓库，如</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/DopamineNone/testGit.git</span><br></pre></td></tr></table></figure><p>其中<code>origin</code>是指远程仓库的默认名称。</p><h3 id="查看绑定的远程仓库"><a href="#查看绑定的远程仓库" class="headerlink" title="查看绑定的远程仓库"></a>查看绑定的远程仓库</h3><p>使用<code>git remote -v</code>可以查看：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  http://github.com/DopamineNone/testGit.git (fetch)</span><br><span class="line">origin  http://github.com/DopamineNone/testGit.git (push)</span><br></pre></td></tr></table></figure><p>这与<code>.git/config</code>文件中记录的一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = https://github.com/DopamineNone/testGit.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure><h3 id="设置不同的push和fetch-url"><a href="#设置不同的push和fetch-url" class="headerlink" title="设置不同的push和fetch url"></a>设置不同的push和fetch url</h3><p><code>git remote set-url --push &lt;name&gt; &lt;newurl&gt;</code>可以单独设置push url</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="built_in">set</span>-url --push origin https://DopamineNone/testGithubFlow.git</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  http://github.com/DopamineNone/testGit.git (fetch)</span><br><span class="line">origin  http://DopamineNone/testGithubFlow.git (push)</span><br></pre></td></tr></table></figure><blockquote><p>该设置常用于fork仓库中：即本地仓库与源开源仓库同步(fetch)，推送时讲本地提交更新至远程fork仓库(push)</p></blockquote><h3 id="推送本地提交信息"><a href="#推送本地提交信息" class="headerlink" title="推送本地提交信息"></a>推送本地提交信息</h3><p>前文中只标识了远程仓库的地址的默认别名<code>origin</code>，如将本地提交推送至远程<strong>空仓库</strong>时，还需要绑定分对应的upstream</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>这一步就是将本地<code>main</code>分支的upstream设置为<code>orign/main</code>(-u选项的作用)，并<strong>执行推送</strong>。(但仍然不会设置其他分支的upstream)</p><p>也可以主动修改本地分支的upstream：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="built_in">set</span>-upstream-to=origin/feature feature</span><br></pre></td></tr></table></figure><p>就是将<code>feature</code>分支的upstream设置为<code>origin/feature</code>。</p><p>如果当前分支<code>feat1</code>没有设置upstream，但main分支设置了，可以直接使用<code>git push origin feat1</code>，这会将<code>feat1</code>推送至<code>origin/feat1</code>（但仍然不会设置<code>feat1</code>的upstream）</p><p>如果当前分支<code>feat2</code>的upstream已经设置为origin，那么就可以直接执行<code>git push</code>，等价于&#96;git push origin feat2</p><h3 id="获取远程仓库最新提交信息"><a href="#获取远程仓库最新提交信息" class="headerlink" title="获取远程仓库最新提交信息"></a>获取远程仓库最新提交信息</h3><p>前提是本地main分支设置了upstream</p><p><code>git fetch &lt;repository&gt; &lt;branch&gt;</code>命令可以获取远程仓库相应分支的最新提交信息</p><blockquote><p>不指明repository和branch时，等效于<code>git fetch origin 与当前本地分支同名的远端分支</code></p></blockquote><p>获取远程仓库最新提交信息后还需要<code>git merge</code>合并一下。</p><p>或者使用<code>git pull &lt;repository&gt; &lt;branch&gt;</code>命令，等价于<code>git fetch &lt;repository&gt; &lt;branch&gt;</code>+<code>git merge</code></p><p>如果当前分支<code>feat</code>已经设置了upstream为<code>orign/feat</code>，那么<code>git pull</code>等价于<code>git pull origin feat</code></p><h2 id="分支管理工作流"><a href="#分支管理工作流" class="headerlink" title="分支管理工作流"></a>分支管理工作流</h2><p>有了上述的基础，我们就可以了解实际研发中的分支管理。常见的分支管理流有：Git Flow，Github Flow以及Gitlab Flow。推荐阮一峰大佬的博文：<a href="https://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a>，本文就不赘述相关内容。</p><p><img src="/2025/01/20/Git%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(2)/bg2015122301.png"></p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tool </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang之Cobra基本使用</title>
      <link href="/2025/01/19/Golang%E4%B9%8BCobra%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/01/19/Golang%E4%B9%8BCobra%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本博客通过构建命令行工具to-do-list来介绍cobra的基本使用方式。工具的功能参考<a href="https://roadmap.sh/projects/task-tracker">Task Tracker</a></p><h2 id="获取cobra"><a href="#获取cobra" class="headerlink" title="获取cobra"></a>获取cobra</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/spf13/cobra@latest</span><br></pre></td></tr></table></figure><h2 id="cobra-Command"><a href="#cobra-Command" class="headerlink" title="cobra.Command"></a>cobra.Command</h2><p>创建工作目录，结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmd</span><br><span class="line">│   └── root.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── main.go</span><br></pre></td></tr></table></figure><p><code>cmd</code>目录下编写和命令行处理相关的模块，其中cobra中的核心就是<code>cobra.Command</code>结构体，以下是其最基本的的几个字段</p><ul><li><code>Use</code>：当前命令的用法（根命令不需要），并取其第一个单词作为命令的标识符</li><li><code>Short</code>：当前命令的简短说明</li><li><code>Long</code>：当前命令的长说明</li><li><code>Run</code>：当前命令的处理函数，类型为<code>func(cmd *cobra.Command，args []string)</code></li><li><code>RunE</code>：当前命令的处理函数，类型为<code>func(cmd *cobra.Command, args []string) error</code>，返回的错误能够被<code>Execute()</code>方法返回</li></ul><p>常用的方法：</p><ul><li><code>Execute() error</code>，解析命令行，并在cmd数中找到匹配的命令进行处理，返回可能的错误</li><li><code>AddCommand(cmd *cobra.Command)</code>，在当前命令下添加子命令</li></ul><p>其他常用的字段和方法也会在后文中介绍到。</p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p><code>cmd/root.go</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/spf13/cobra&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">Short: <span class="string">&quot;Todo App&quot;</span>,</span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello ToDo_JSON! v1.0.0&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装root命令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := rootCmd.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.go</code>中调用命令行处理接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;todo_json/cmd&quot;</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cmd.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在工作根目录下执行以下命令验证：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go run .                                 </span><br><span class="line">&gt; Hello ToDo! v1.<span class="number">0</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line">$ go run . -h</span><br><span class="line">&gt; Todo App</span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Usage:</span></span><br><span class="line"><span class="function">   [<span class="title">flags</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Flags</span>:</span></span><br><span class="line"><span class="function">  -<span class="title">h</span>, --<span class="title">help</span>   <span class="title">help</span> <span class="title">for</span> <span class="title">this</span> <span class="title">command</span></span></span><br></pre></td></tr></table></figure><p>当然也能先调用<code>go build</code>编译成可执行文件再进行命令行操作。</p><h2 id="增加子命令"><a href="#增加子命令" class="headerlink" title="增加子命令"></a>增加子命令</h2><p>ToDo工具主要需要五个操作：<code>add</code>，<code>update</code>，<code>delete</code>，<code>list</code>，<code>mark</code>；可以将这些操作设计为五个子命令</p><p>项目目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmd</span><br><span class="line">│   ├── add</span><br><span class="line">│   │   └── add.go</span><br><span class="line">│   ├── delete</span><br><span class="line">│   │   └── delete.go</span><br><span class="line">│   ├── list</span><br><span class="line">│   │   └── list.go</span><br><span class="line">│   ├── mark</span><br><span class="line">│   │   └── mark.go</span><br><span class="line">│   ├── root.go</span><br><span class="line">│   └── update</span><br><span class="line">│       └── update.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── main.go</span><br></pre></td></tr></table></figure><blockquote><p>cobra官方推荐通过新建子目录管理子命令模块</p></blockquote><p>以<code>cmd/add/add.go</code>为例，创建新的子命令<code>addCmd</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> add</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/spf13/cobra&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AddCmd = &amp;cobra.Command&#123;</span><br><span class="line">Use:   <span class="string">&quot;add &#123;task&#125;&quot;</span>, </span><br><span class="line">Short: <span class="string">&quot;add a new task&quot;</span>,</span><br><span class="line">Run:   addFunc,    <span class="comment">// 通过`go run . add`可以调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addFunc</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// TO DO:</span></span><br><span class="line">fmt.Println(<span class="string">&quot;using todo.add ...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>cmd/root.go</code>中加入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">rootCmd.AddCommand(add.AddCmd)</span><br><span class="line">rootCmd.AddCommand(<span class="built_in">delete</span>.DeleteCmd)</span><br><span class="line">rootCmd.AddCommand(update.UpdateCmd)</span><br><span class="line">rootCmd.AddCommand(list.ListCmd)</span><br><span class="line">rootCmd.AddCommand(mark.MarkCmd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令行验证一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run . add</span><br><span class="line">&gt; using todo.add ...</span><br></pre></td></tr></table></figure><h2 id="位置参数-Positional-Args"><a href="#位置参数-Positional-Args" class="headerlink" title="位置参数 Positional Args"></a>位置参数 Positional Args</h2><p>在该部分，我们将实现各个命令的位置参数验证，以<code>list</code>子命令为例，我们规定：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">todo_json list all 列出所有任务</span><br><span class="line">todo_json list todo 列出todo状态的任务</span><br><span class="line">todo_json list <span class="keyword">in</span>-progress 列出<span class="keyword">in</span>-progress状态的任务</span><br><span class="line">todo_json list done 列出done状态的任务</span><br></pre></td></tr></table></figure><h3 id="Command中相关字段"><a href="#Command中相关字段" class="headerlink" title="Command中相关字段"></a>Command中相关字段</h3><p><code>cobra.Command</code>中关于位置参数有两个常用的字段：</p><ul><li><code>Args</code>：类型为<code>cobra.PositionalArgs</code>，位置参数的验证器，可以指定位置参数的数量，内容等</li><li><code>ValidArgs</code>：类型为<code>[]string</code>，指定合法的位置参数，可用作命令补全中</li></ul><h3 id="参数数量验证器"><a href="#参数数量验证器" class="headerlink" title="参数数量验证器"></a>参数数量验证器</h3><p>cobra提供了一些内置的参数验证器，如：</p><ul><li><code>NoArgs</code>，表明当前命令不需要位置参数，命令后第一个参数会尝试解析成子命令<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> AddCmd = &amp;cobra.Command&#123;</span><br><span class="line">Use:   <span class="string">&quot;add [task]&quot;</span>,</span><br><span class="line">Short: <span class="string">&quot;add a new task&quot;</span>,</span><br><span class="line">Args:  cobra.NoArgs,</span><br><span class="line">Run:   addFunc,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>测试结果：<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run . add &quot;something&quot;</span><br><span class="line">&gt; Error: unknown command &quot;something&quot; <span class="keyword">for</span> &quot; add&quot; ...</span><br></pre></td></tr></table></figure></li></ul><p>其他参数<strong>数量</strong>验证器有：</p><ul><li><code>ArbitraryArgs</code>，表明可接受任意个参数，为<code>Args</code>的默认值(即<code>Args</code>为nil时仍使用<code>ArbitraryArgs</code>)</li><li><code>MinimumNArgs(n)</code>，表示最少接受n个参数，少于n个参数会报错</li><li><code>MaximumNArgs(n)</code>，表示最多接受n个参数，多于n个参数会报错</li><li><code>ExactArgs(n)</code>，表示只接受n个参数，多或少于n个参数会报错</li><li><code>RangeArgs(min, max)</code>，表示接受[min, max]个参数</li></ul><h3 id="参数内容验证器"><a href="#参数内容验证器" class="headerlink" title="参数内容验证器"></a>参数内容验证器</h3><p>还有参数<strong>内容</strong>验证其有：</p><ul><li><code>OnlyValidArgs</code>，会检测参数是否在<code>ValidArgs</code>中</li></ul><h3 id="组合参数验证器"><a href="#组合参数验证器" class="headerlink" title="组合参数验证器"></a>组合参数验证器</h3><p>想要使用多个验证器时，可以使用<code>MatchAll(pargs ...PositionalArgs)</code>。</p><p>这里完成<code>ListCmd</code>的参数校验：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">TODO        = <span class="string">&quot;todo&quot;</span></span><br><span class="line">IN_PROGRESS = <span class="string">&quot;in-progress&quot;</span></span><br><span class="line">DONE        = <span class="string">&quot;done&quot;</span></span><br><span class="line">ALL         = <span class="string">&quot;all&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ListCmd = &amp;cobra.Command&#123;</span><br><span class="line">Use:       <span class="string">&quot;list &#123;todo|in-progress|done&#125;&quot;</span>,</span><br><span class="line">Short:     <span class="string">&quot;list the tasks of specified type&quot;</span>,</span><br><span class="line">ValidArgs: []<span class="type">string</span>&#123;TODO, IN_PROGRESS, DONE, ALL&#125;,</span><br><span class="line">Args:      cobra.MatchAll(cobra.ExactArgs(<span class="number">1</span>), cobra.OnlyValidArgs),</span><br><span class="line">Run:       ListFunc,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListFunc</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> args[<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> TODO:</span><br><span class="line">fmt.Println(<span class="string">&quot;List of todo:&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> IN_PROGRESS:</span><br><span class="line">fmt.Println(<span class="string">&quot;List of in-progress:&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> DONE:</span><br><span class="line">fmt.Println(<span class="string">&quot;List of done:&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> ALL:</span><br><span class="line">fmt.Println(<span class="string">&quot;List of all:&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go run . list todo</span><br><span class="line">&gt; List of todo:</span><br><span class="line"></span><br><span class="line">$ go run . list undone </span><br><span class="line">&gt; Error: invalid argument &quot;undone&quot; <span class="keyword">for</span> &quot; list&quot;</span><br></pre></td></tr></table></figure><h3 id="自定义参数验证器"><a href="#自定义参数验证器" class="headerlink" title="自定义参数验证器"></a>自定义参数验证器</h3><p> 也可以通过自定义函数<code>func(cmd *cobra.Command, args []string) error</code>来实现自定义验证器，以<code>update</code>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmd/update/update.go</span></span><br><span class="line"><span class="keyword">var</span> UpdateCmd = &amp;cobra.Command&#123;</span><br><span class="line">Use:   <span class="string">&quot;update &#123;id&#125; &#123;task&#125;&quot;</span>,</span><br><span class="line">Short: <span class="string">&quot;update specified task content&quot;</span>,</span><br><span class="line">Args:  cobra.MatchAll(cobra.ExactArgs(<span class="number">2</span>), utils.CheckNum(<span class="number">1</span>)),</span><br><span class="line">Run:   UpdateFunc,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// utils/validation.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckNum</span><span class="params">(n <span class="type">int</span>)</span></span> cobra.PositionalArgs &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">_, err := strconv.Atoi(args[n<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选项-标志位-Flags"><a href="#选项-标志位-Flags" class="headerlink" title="选项&#x2F;标志位 Flags"></a>选项&#x2F;标志位 Flags</h2><p>在这一部分，我们将使用选项来实现<code>mark</code>子命令，我们规定：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">todo_json mark &#123;id&#125; --inprogress 将任务标记为<span class="keyword">in</span>-progress </span><br><span class="line">todo_json mark &#123;id&#125; --done 将任务标记为done</span><br></pre></td></tr></table></figure><h3 id="Command中不同的FlagSet"><a href="#Command中不同的FlagSet" class="headerlink" title="Command中不同的FlagSet"></a>Command中不同的FlagSet</h3><p>在cobra中，每个命令（Command）都拥有几个<code>Flags Set</code>：</p><ul><li><code>Persistent Flags Set</code>：在该标志集中定义的flag能够被子命令所继承</li><li><code>Inherit Flags Set</code>：存放所有继承自<strong>父命令</strong><code>Persistent Flags Set</code>和<code>Inherit Flags Set</code>的标志</li><li><code>Local Flags Set</code>：等同于<code>NonInherited Flags Set</code>，存放命令本身定义的标记（包括本身的<code>Persistent Flags Set</code>），不包括继承的标记。</li><li><code>Flags Set</code>：上述所有标记的并集。</li></ul><p>获取对应标志集的方法：</p><ul><li><code>cmd.PersistentFlags()</code></li><li><code>cmd.InheritedFlags()</code></li><li><code>cmd.LocalFlags()</code>或<code>cmd.NonInheritedFlags()</code></li><li><code>cmd.Flags()</code></li></ul><h3 id="定义标记"><a href="#定义标记" class="headerlink" title="定义标记"></a>定义标记</h3><p>向标志集定义标志&#x2F;选项的方法，以String类型标记为例：</p><ul><li><code>flagSet.String(tagName, defaultValue, usage)</code>，定义一个<code>--tagName</code>的String类型标签，并返回存放解析结果的变量指针<code>*String</code></li><li><code>flagSet.StringP(tagName, shortHand, defaultValue, usage)</code>，与<code>flagSet.String</code>类似，但增加了短选项别名<code>-shortHand</code>，其中<code>shortHand</code>是一个字符</li><li><code>flagSet.StringVar(p *String, tagName, defaultValue, usage)</code>，会将解析结果保存在存入的p指针指向的变量中。</li><li><code>flagSet.StringVarP(p *String, tagName, shortHand, defaultValue, usage)</code>，与<code>flagSet.StringVar</code>类似，但增加了短选项别名<code>-shortHand</code>，其中<code>shortHand</code>是一个字符</li></ul><p>类似的定义其他基本类型标记的方法有：</p><ul><li>整型类型（Int, Uint, Uint16等）：如<code>flagSet.Int(...)</code>, <code>flagSet.Uint16VarP(...)</code></li><li>浮点类型（Float32，Float64等）：如<code>flagSet.Float32(...)</code></li><li>布尔类型：如：<code>flagSet.Bool(...)</code></li></ul><p>还有定义基本类型的切片类型标记的方法，如：<code>flagSet.IntSlice(...)</code>, <code>flagSet.IntSliceVar(...)</code>, <code>flagSet.IntSliceVarP(...)</code></p><blockquote><ol><li>标志的定义必须在命令行<strong>解析前</strong>完成，一般在所在包的init函数中定义；在<code>Command.Run</code>或<code>Command.RunE</code>的函数体中定义会产生错误！</li><li><code>flagSet.Flags()</code>能获取所有继承和本地的标记集，但通过<code>flag.Flags()</code>定义的标记只会是本地标记，不会传给子命令</li></ol></blockquote><h3 id="获取标记值"><a href="#获取标记值" class="headerlink" title="获取标记值"></a>获取标记值</h3><p>在命令行解析后获取相应的标记&#x2F;选项的值，除了使用标记定义方法返回&#x2F;传入的指针变量外，还可以通过<code>flagSet.GetXXX(tagName)</code>获取，其中XXX位相应标记的类型，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> user, err := cmd.Flags().GetString(<span class="string">&quot;name&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标记分组"><a href="#标记分组" class="headerlink" title="标记分组"></a>标记分组</h3><p>cobra还允许开发者使用分组来实现不同标记之间的关系，如：</p><ul><li><code>cmd.MarkFlagsRequiredTogether(tagName...)</code>, 要求某些标记必须在命令行同时出现</li><li><code>cmd.MarkFlagsMutuallyExclusive(tagName...)</code>，要求某些标记不能同时出现</li><li><code>cmd.MarkFlagsOneRequired(tagName...)</code>，要求某些标记至少出现一个</li></ul><p>接下来，我们就可以利用上述的内容，完成<code>mark</code>命令的标记定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">IN_PROGRESS = <span class="string">&quot;inprogress&quot;</span></span><br><span class="line">DONE        = <span class="string">&quot;done&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">in   <span class="type">bool</span></span><br><span class="line">done <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MarkCmd = &amp;cobra.Command&#123;</span><br><span class="line">Use:   <span class="string">&quot;mark &#123;id&#125;&quot;</span>,</span><br><span class="line">Short: <span class="string">&quot;mark the specified task in some state&quot;</span>,</span><br><span class="line">Args:  cobra.MatchAll(cobra.ExactArgs(<span class="number">1</span>), utils.CheckNum(<span class="number">1</span>)),</span><br><span class="line">Run:   MarkFunc,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarkFunc</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> in &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;in progress&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> done &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">MarkCmd.Flags().BoolVar(&amp;in, IN_PROGRESS, <span class="literal">false</span>, <span class="string">&quot;mark task with in-progress status&quot;</span>)</span><br><span class="line">MarkCmd.Flags().BoolVar(&amp;done, DONE, <span class="literal">false</span>, <span class="string">&quot;mark task with done status&quot;</span>)</span><br><span class="line">MarkCmd.MarkFlagsMutuallyExclusive(IN_PROGRESS, DONE)</span><br><span class="line">MarkCmd.MarkFlagsOneRequired(IN_PROGRESS, DONE)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go run . mark <span class="number">1</span></span><br><span class="line"><span class="function">Error: <span class="title">at</span> <span class="title">least</span> <span class="title">one</span> <span class="title">of</span> <span class="title">the</span> <span class="title">flags</span> <span class="title">in</span> <span class="title">the</span> <span class="title">group</span> [<span class="title">inprogress</span> <span class="title">done</span>] <span class="title">is</span> <span class="title">required</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">$ <span class="title">go</span> <span class="title">run</span> . <span class="title">mark</span> 1 --<span class="title">inprogress</span> --<span class="title">done</span></span></span><br><span class="line"><span class="function"><span class="title">Error</span>: <span class="title">if</span> <span class="title">any</span> <span class="title">flags</span> <span class="title">in</span> <span class="title">the</span> <span class="title">group</span> [<span class="title">inprogress</span> <span class="title">done</span>] <span class="title">are</span> <span class="title">set</span> <span class="title">none</span> <span class="title">of</span> <span class="title">the</span> <span class="title">others</span> <span class="title">can</span> <span class="title">be</span>; [<span class="title">done</span> <span class="title">inprogress</span>] <span class="title">were</span> <span class="title">all</span> <span class="title">set</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">$ <span class="title">go</span> <span class="title">run</span> . <span class="title">mark</span> 1 --<span class="title">inprogress</span></span></span><br><span class="line"><span class="function"><span class="title">in</span> <span class="title">progress</span></span></span><br></pre></td></tr></table></figure><p>以上就是Cobra的基础内容了，想利用Cobra的高级特性参考<a href="https://github.com/spf13/cobra/blob/main/site/content/user_guide.md">文档</a>，todo_json的<a href="https://github.com/DopamineNone/todo_json">开源仓库</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 依赖管理</title>
      <link href="/2025/01/15/Golang%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
      <url>/2025/01/15/Golang%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Golang发展至今，其依赖管理方式有了几次变革。本文对Golang的不同依赖管理方式进行总结。</p><ul><li>GOPATH (最早的依赖管理方式)</li><li>Go vendor (v1.5)</li><li>Go Modules (v1.11至今，默认开启，适用于生产环境)</li></ul><h2 id="GOPATH-（了解即可）"><a href="#GOPATH-（了解即可）" class="headerlink" title="GOPATH （了解即可）"></a>GOPATH （了解即可）</h2><p>最早Go通过GOPATH环境变量进行依赖管理。GOPATH是一个环境变量，存储着Go的工作目录（项目目录）。在该目录下，通常包含<code>src</code>、<code>pkg</code>和<code>bin</code>三个子目录，其中src存放项目源代码，pkg存放编译后的包对象文件，bin存放编译后生成的可执行文件。</p><p>Go 编译器在编译项目时，会在 GOPATH 下的src目录及其子目录中查找所需的依赖包。当多个 Go 项目需要使用相同的代码包时，可以将这些代码包统一放在 GOPATH 下的src目录中，实现代码的共享和复用。GOPATH模式下，执行<code>go get</code>命令下载依赖也是将依赖保存在<code>GOPATH/src</code>下。</p><blockquote><p>如果GOPATH存在多个路径地址，go get会将依赖下载到第一个路径的src目录中</p></blockquote><p>所以GOPATH模式下的依赖管理的缺点很明显：</p><ul><li><code>go get</code>会将依赖下载到<code>src</code>目录下，本地代码与第三方代码混合管理，使项目文件混乱</li><li>当GOPATH使用多个路径地址管理不同项目，即使依赖相同的包也得分开保存在各自的<code>src</code>目录中，造成磁盘浪费</li></ul><h2 id="Go-vendor-（Gov1-5-v1-10，了解即可）"><a href="#Go-vendor-（Gov1-5-v1-10，了解即可）" class="headerlink" title="Go vendor （Gov1.5-v1.10，了解即可）"></a>Go vendor （Gov1.5-v1.10，了解即可）</h2><p>在Go v1.5时，Golang引入了vendor模式，即将项目的所有<strong>外部依赖包</strong>保存在项目的<code>vendor</code>目录中。Go v1.5-v1.10，即还没GOMODULE模式时，通常会使用第三方工具 govendor 来管理 vendor 目录。如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化项目根目录下的vendor目录</span></span><br><span class="line">govendor init </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为项目添加依赖</span></span><br><span class="line">govendor add github.com/example/package</span><br></pre></td></tr></table></figure><p>想启用 vendor 模式，需要设置 GO15VENDOREXPERIMENT 环境变量为 1（较新版本的Go中已经不存在该变量）。然后使用正常的 go build 命令进行构建，此时 Go 编译器会优先从 vendor 目录中查找依赖包而不是 GOPATH&#x2F;src 中。</p><blockquote><p>新版本Go中在Go Modules模式下，打包程序时想加入vendor目录中的依赖，只需要使用命令<code>go build -mod=vendor</code>即可</p></blockquote><h2 id="Go-Module"><a href="#Go-Module" class="headerlink" title="Go Module"></a>Go Module</h2><p>在Gov1.11时，Golang引入了Go Module模式：</p><ul><li>将<code>go get</code>下载的依赖统一保存在<code>GOPATH/pkg/mod</code>目录下</li><li>在项目的根目录使用<code>go.mod</code>文件管理项目的依赖以及其版本</li><li>在项目的根目录使用<code>go.sum</code>文件保存每个依赖包的哈希值（包括依赖包的直接依赖和间接依赖），用于验证从远程仓库下载的依赖包是否与之前使用的是同一版本</li></ul><p>Go Modules是目前Go使用的最广泛的依赖管理方式。作用有：</p><ul><li>版本控制与依赖管理<ul><li>精确版本控制：Go Module 可以明确指定项目所依赖的各个模块的版本号，确保项目在不同环境下使用的是相同版本的依赖</li><li>依赖自动解析：在构建项目时，Go Module 会自动解析项目的依赖关系，并下载所需的依赖模块及其所有间接依赖</li><li>避免依赖冲突：当多个依赖模块依赖于同一个模块的不同版本时，Go Module 会尝试解决版本冲突，选择一个能够满足所有依赖的版本。</li></ul></li><li>项目隔离与可重复性<ul><li>环境隔离：Go Module 为每个项目提供了独立的依赖环境，使得项目的构建不依赖于全局的GOPATH设置。</li><li>可重复性构建：由于 Go Module 精确地记录了项目的依赖版本，只要go.mod文件和相关的依赖文件不变，项目在任何环境下都可以进行相同的构建，保证了项目构建的可重复性</li></ul></li><li>模块发布与共享<ul><li>Go Module 简化了模块的发布过程。开发者可以将自己编写的模块发布到公共的模块仓库（如proxy.golang.org），供其他开发者使用。发布时，只需要按照 Go Module 的规范设置好模块的版本号和依赖关系，就可以轻松地将模块分享给其他人。</li></ul></li></ul><h3 id="Go-Module开启设置"><a href="#Go-Module开启设置" class="headerlink" title="Go Module开启设置"></a>Go Module开启设置</h3><p>Golang通过环境变量<code>GO111MODULE</code>来控制Go Module模式的开启（默认开启），总共有三个可选的值：</p><ul><li>auto： go自主根据当前项目目录进行判断是否使用Go Module模式。当目录满足以下条件时使用Go Module模式：<ul><li>不在<code>GOPATH/src</code>下</li><li>当前或上一级目录中存在<code>go.mod</code>文件</li></ul></li><li>on：开启Go Module</li><li>off：使用GOPATH模式</li></ul><h3 id="go-mod-命令"><a href="#go-mod-命令" class="headerlink" title="go mod 命令"></a>go mod 命令</h3><p>Golang提供了一系列<code>go mod</code>命令进行依赖管理，常用的有：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>go mod init &lt;module_name&gt;</td><td>在当前目录下生成go.mod文件，并设置包名为<module_name></td></tr><tr><td>go mod tidy</td><td>会扫描当前项目所有源文件中导入语句，更新go.mod和go.sum：添加未声明的依赖，移除未使用的依赖</td></tr><tr><td>go mod download</td><td>根据项目的 go.mod 文件中列出的依赖信息，将所需的依赖包及其相应版本下载到本地的模块缓存（GOPATH&#x2F;pkg&#x2F;mod）中</td></tr><tr><td>go mod verify</td><td>校验模块是否被篡改过</td></tr><tr><td>go mod vendor</td><td>将依赖的模块保存在项目的vendor目录下</td></tr><tr><td>go mod why &lt;module_name&gt;</td><td>输出项目中引入某个包的原因</td></tr><tr><td>go mod graph</td><td>输出项目中的依赖列表</td></tr></tbody></table><h3 id="go-mod格式"><a href="#go-mod格式" class="headerlink" title="go.mod格式"></a>go.mod格式</h3><p>go.mod文件的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双斜杠表示注释</span></span><br><span class="line"><span class="comment">// module &lt;name&gt; 指明当前模块名，不使用双引号</span></span><br><span class="line">module github.com/DopamineNone/test</span><br><span class="line"></span><br><span class="line"><span class="comment">// Golang SDK版本</span></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.23</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明项目所依赖的外部包及其相应的版本信息</span></span><br><span class="line">require (</span><br><span class="line">    github.com/example/<span class="keyword">package</span> v1<span class="number">.2</span><span class="number">.3</span></span><br><span class="line">    github.com/another/<span class="keyword">package</span> v2<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许你排除特定版本的依赖包，防止它们被引入到项目中</span></span><br><span class="line">exclude (</span><br><span class="line">github.com/example/<span class="keyword">package</span> v1<span class="number">.5</span><span class="number">.0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换依赖的源路径或版本，常见于代理情况</span></span><br><span class="line">replace (</span><br><span class="line">github.com/example/<span class="keyword">package</span> v1<span class="number">.2</span><span class="number">.3</span> =&gt; github.com/myfork/<span class="keyword">package</span> v1<span class="number">.2</span><span class="number">.4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当项目作为模块被引用时，用于标记本模块不应该被使用的版本，即使它们可能已经在 require 部分列出</span></span><br><span class="line">retract (</span><br><span class="line">    v1<span class="number">.0</span><span class="number">.0</span> <span class="comment">// 有 bug，不建议使用</span></span><br><span class="line">    v1<span class="number">.1</span><span class="number">.0</span>-rc<span class="number">.1</span> <span class="comment">// 预发布版本，不稳定</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="外部包引用规则"><a href="#外部包引用规则" class="headerlink" title="外部包引用规则"></a>外部包引用规则</h2><p>引用前需要使用<code>go get</code>命令将外部包保存在本地缓存中。</p><p>无论是哪种模式下，直接<code>import &quot;包名&quot;</code>就可以实现外部包的引用。如:</p><ul><li><code>import &quot;github.com/example/package&quot;</code></li></ul><h2 id="本地包引用规则"><a href="#本地包引用规则" class="headerlink" title="本地包引用规则"></a>本地包引用规则</h2><ol><li>Golang 不允许在同一个目录下有两个不同的包（子目录除外）</li><li>Golang <strong>建议</strong>包名与包所在的目录名一致<br>如：<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-demo</span><br><span class="line">|   |-foo</span><br><span class="line">||  |-foo.go // package foo</span><br><span class="line">||-bar.go //package demo</span><br><span class="line">||-baz.go //package demo</span><br><span class="line">|-main.go</span><br><span class="line">|-go.mod // module test</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p>上述目录结构是没有错误的；如果baz.go的包名改成demo2，就会产生编译冲突，因为 Go 编译器会将一个目录下的所有 .go 文件作为一个整体进行编译和链接操作，bar.go和baz.go的包名不同就会造成编译冲突。</p><p>在不同依赖管理模式下，包的引用方式也略有不同：</p><ul><li>GOPATH模式下，可以通过<code>GOPATH/src</code>的相对路径导入本地包（了解即可）</li><li>Go Module模式下，通过<strong>模块名+目录路径</strong>导入本地包（重点）</li></ul><p>以Go Module模式为例，在<code>main.go</code>中可以通过<code>import &quot;test/demo&quot;</code>引用<code>demo</code>包（<code>bar.go</code>和<code>baz.go</code>），通过<code>import &quot;test/demo/foo</code>来引用<code>foo</code>包（<code>foo.go</code>）</p><p>以下是一个正确的本地包引入例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo/bar.go</span></span><br><span class="line"><span class="keyword">package</span> demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, Bar!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;test/demo&quot;</span> <span class="comment">// 模块名test + 模块下的目录路径/demo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">demo.Bar()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Golang 允许包名与目录名不一致，但可能会导致代码混淆，因为导入语句使用到的是目录名，而引用该包时使用的是包名，以下是一个正确的例子：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo/bar.go</span></span><br><span class="line"><span class="keyword">package</span> bar</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, Bar!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;test/demo&quot;</span> <span class="comment">// 使用的demo是目录名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bar.Bar() <span class="comment">// 引用的bar是包名</span></span><br><span class="line"><span class="comment">// demo.Bar() 是错误的调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有趣的是，笔者在写这篇博客时发现，即使包名与目录名不一致，也可以使用别名导入的方式避免混淆（当然<strong>保持包名与目录名一致仍是最佳实践</strong>），以下是一个正确的例子：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo/bar.go</span></span><br><span class="line"><span class="keyword">package</span> bar</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, Bar!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> demo <span class="string">&quot;test/demo&quot;</span> <span class="comment">// 对demo目录下的bar包使用别名`demo`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">demo.Bar() <span class="comment">// 引用的demo是bar包的别名</span></span><br><span class="line">bar.Bar() <span class="comment">// 通过原包名调用也是正确的（尽管别名存在），但既然定义了别名就尽量使用别名引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-基础数学应用</title>
      <link href="/2025/01/14/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E5%BA%94%E7%94%A8/"/>
      <url>/2025/01/14/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><blockquote><p>定义：大于1的整数中，只有1和本身两个约数的数称作质数</p></blockquote><h3 id="质数的判断"><a href="#质数的判断" class="headerlink" title="质数的判断"></a>质数的判断</h3><p>试除法，复杂度为$O(\sqrt{n})$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) <span class="comment">// 推荐 i &lt;= n / i表示边界</span></span><br><span class="line"><span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><p>试除法，复杂度为$O(\sqrt{n})$</p><blockquote><p>n中最多包含一个大于sqrt(n)的质因子</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_x</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line"><span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">x /= i;</span><br><span class="line">cnt++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, x, cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d 1&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="质数的筛选"><a href="#质数的筛选" class="headerlink" title="质数的筛选"></a>质数的筛选</h3><p>埃氏筛法，复杂度为$O(nloglogn)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> primes[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (!st[N]) &#123;</span><br><span class="line">primes[idx++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i) st[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性筛法，复杂度为$O(n)$</p><blockquote><p>线性是指确保每个合数仅被其最小质因数筛除一次，避免了重复计算</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> primes[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[N]) primes[idx++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++) &#123;</span><br><span class="line">st[primes[j]*i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="求所有约数"><a href="#求所有约数" class="headerlink" title="求所有约数"></a>求所有约数</h3><p>参看质因数分解，复杂度为$O(\sqrt{n})$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x/i; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">ans.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="keyword">if</span> (i != x/i) ans.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[0,n]的所有数的约数总共约有$\frac{n}{1} + \frac{n}{2} + … + \frac{n}{n} \to nlnn \lt nlogn$ ，即平均每个数都有logn个约数，所以get_divisors最后的排序复杂度约为$O(lognloglogn)$，比$O(\sqrt{n})$小</p></blockquote><h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><blockquote><p>公式：对于一个数$x &#x3D; p_{1}^{d_1}p_{2}^{d_2}…p_{n}^{d_n}$ ($p_i$表示素因子)，约数个数为$\Pi_{i &#x3D; 1}^{n}(d_i+1)$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_divisor_quantity</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) </span><br><span class="line">        <span class="keyword">while</span>( n % i == <span class="number">0</span> ) &#123;</span><br><span class="line">            n /= i;</span><br><span class="line">            primes[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) primes[n]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : primes) &#123;</span><br><span class="line">        res = (res * (v + <span class="number">1</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h3><blockquote><p>公式：对于一个数$x &#x3D; p_{1}^{d_1}p_{2}^{d_2}…p_{n}^{d_n}$ ($p_i$表示素因子)，约数总和为$\Pi_{i &#x3D; 1}^{n}(\Sigma_{j&#x3D;0}^{d_i}p_i^j) &#x3D; (p_1^0 + p_1^1 + … + p_1^{d_1})(p_2^0 + p_2^1 + … + p_2^{d_2})…(p_n^0 + p_n^1 + … + p_n^{d_n})$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_divisor_sum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes;</span><br><span class="line">    <span class="type">int</span> total = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) </span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= i;</span><br><span class="line">            primes[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) primes[n]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [p, cnt] : primes) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">            t = (t * p + <span class="number">1</span>) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = (sum * t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>也称辗转相除法，用于求两个数的最大公约数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><blockquote><p>对于任意正整数a,b，一定存在整数x,y，使得$ax + by &#x3D; gcd(a,b)$；欧几里得算法的作用就是能求出x,y的一个特解</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) &#123;</span><br><span class="line">x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a%b, y, x);</span><br><span class="line"><span class="comment">// d == yb + x(a%b) == yb + x(a - a/b*b) == xa + (y-a/b*x)b</span></span><br><span class="line">y -= a / b * x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：求解线性同余方程 (ax &#x3D; b (mod m)))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, m, x, y;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; m;</span><br><span class="line"><span class="type">int</span> d = <span class="built_in">exgcd</span>(a, m, x, y);</span><br><span class="line"><span class="keyword">if</span> (b % d) cout &lt;&lt; <span class="string">&quot;no solution&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; (LL)x * (b / d) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展欧几里得算法也常用于求逆元。</p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><blockquote><p>$\varphi(n)$表示[1, n]中与n互质的数的个数，其中$n &#x3D; p_1^{d_1}p_2^{d_2}…p_n^{d_n})$，则$\varphi(n) &#x3D; n(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_n})$ ，证明可用容斥原理</p></blockquote><p>复杂度为$O(\sqrt{n})$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="comment">// get primes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h2><p>用于求解[1, n]中每个数对应的欧拉函数值，利用<strong>线性筛法</strong>，复杂度为$O(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> phi[N], primes[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">primes[idx++] = i;</span><br><span class="line">phi[i] = i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++) &#123;</span><br><span class="line">st[i*primes[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">phi[i*primes[j]] = primes[j] * phi[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[i*primes[j]] = (primes[j] - <span class="number">1</span>) * phi[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><blockquote><p>对于a与n互质，则$a^{\varphi(n)} &#x3D; 1 (mod n)$</p></blockquote><blockquote><p>证明原理：对于a与n互质，且b与n互质，则ab与n互质</p></blockquote><blockquote><p>（引理）费马小定理： 对于a与素数p互质，则$a^{p-1} &#x3D; 1 (mod p)$，即a模p的逆元为$a^{p-2}$，可通过快速幂计算</p></blockquote><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>对于$a^k mod n$，复杂度为$O(logk)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_exp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>, tmp = a % n;</span><br><span class="line"><span class="keyword">while</span> (k) &#123;</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL) res * tmp % n;</span><br><span class="line">k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">tmp = (LL)tmp * tmp % n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：快速幂求逆元（利用欧拉定理）略</p><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>$$<br>\begin{cases}<br>x \equiv a_1 \pmod{m_1} \<br>x \equiv a_2 \pmod{m_2} \<br>\vdots \<br>x \equiv a_k \pmod{m_k}<br>\end{cases}<br>$$<br>其中$m_i$两两互质<br>令$M &#x3D; m_1m_2…m_k$，$M_i &#x3D; \frac{M}{m_i}$，$M_i^{-1}$表示$M_i$模$m_i$的逆元，则有<br>$$<br>    x &#x3D; a_1M_1M_1^{-1} + a_2M_2M_2^{-1} + … + a_kM_kM_k^{-1}<br>$$</p><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><p>高斯消元是一种用于求解线性方程组的经典方法</p><p>将方程式可以转化为一个<strong>增广矩阵</strong>，并通过初等行列变换求出等价的<strong>上三角形矩阵</strong>，就能依次消元求出$x_n$到$x_1$的一个解</p><blockquote><p>初等行列变换一共有三个操作：</p><ol><li>把某一行乘一个非零的数</li><li>交换某两行</li><li>把某行的若干倍加到另一行上</li></ol><p>上三角形矩阵的三个形态代表三种解：</p><ol><li>完美阶梯梯形：唯一解</li><li>0 &#x3D; 非零：无解</li><li>0 &#x3D; 0：无穷解</li></ol></blockquote><p>求解步骤：</p><ol><li>矩阵转化为上三角形矩阵<ol><li>从当前行r开始，找出[r,n)行中第c个系数（首个非零的系数）最大的行，与第r行交换</li><li>将第r行的首个系数压缩为1</li><li>利用第r行依次将(r, n)行的第c个系数消为0</li></ol></li><li>从第n-1行向第0行遍历，使当前行i利用第j行的结果，消除掉所有第j个参数（j &gt; i)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gaussion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> c, r;</span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt;= n; c++) &#123;</span><br><span class="line"><span class="comment">// find max first-argument row</span></span><br><span class="line"><span class="type">int</span> t = r;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt;= n; i++) </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">t = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if c-argument is all zero, skip</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt;= eps) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap row</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++) <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// make c-argument to 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i--) a[r][i] /= a[r][c];</span><br><span class="line"></span><br><span class="line"><span class="comment">// elimination</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j--) </span><br><span class="line">a[i][j] -= a[i][c] * a[r][j];</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if a is not a perfect top-triangle matrix </span></span><br><span class="line"><span class="keyword">if</span> (r &lt; n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++) </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps) <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// no solution</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// infinite solution</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get answer</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h2><p>方式一：利用公式$C_a^b &#x3D; C_{a-1}^b + C_{a-1}^{b-1}$，可以实现$O(n^2)$复杂度计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> c[N][N]; <span class="comment">//全局遍历初始化为0，故c[i][j] = 0 (j &gt; i)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_comb</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line"><span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> c[i][j] = (c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j]) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：预处理得到$fact[i] \equiv i! mod (10^9+7)$和$infact[i]&#x3D;(i!)^{-1} mod (10^9+7)$，使得$C_a^b \equiv \frac{a!}{b!(a-b)!} &#x3D; ((fact[a]*infact[b])%mod * infact[a-b])%mod$ ,复杂度为$O(nlogp)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> fact[N], infact[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂求逆元</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k) &#123;</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">a = (LL)a * a % p</span><br><span class="line">k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">fact[i] = (LL)fact[i<span class="number">-1</span>] * i % mod;</span><br><span class="line">infact[i] = (LL)infact[i<span class="number">-1</span>] * <span class="built_in">qmi</span>(i, mod<span class="number">-2</span>, mod) % p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_comb</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (LL)fact[a] * infact[b] % p * infact[a-b] % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式三：卢卡斯定理，$C_a^b \equiv C_{a mod p}^{b mod p} * C_{a&#x2F;p}^{b&#x2F;p}(mod p)$，复杂度为$O(nlognlog_pN)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--) &#123;</span><br><span class="line">res = (LL) res * j % p;</span><br><span class="line">res = (LL) res * <span class="built_in">qmi</span>(i, q - <span class="number">2</span>, q) % q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b); </span><br><span class="line"><span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p) * <span class="built_in">lucas</span>(a / p, b / p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式四：素因数表示法，由于解决高精度整数问题</p><p>核心步骤：</p><ol><li>获得小于等于a的所有素数</li><li>获取$C_a^b$中每个素因子的指数</li><li>通过大数乘法求得$C_a^b$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> primes[N], sum[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) primes[idx++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++) &#123;</span><br><span class="line">st[i*primes[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> p)</span> </span>&#123; <span class="comment">// 计算a!中p的指数</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a) &#123;</span><br><span class="line">res += a / p;</span><br><span class="line">a /= p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">carry += a[i] * p;</span><br><span class="line">res.<span class="built_in">push_back</span>(carry % <span class="number">10</span>);</span><br><span class="line">carry /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (carry) &#123;</span><br><span class="line">res.<span class="built_in">push_back</span>(carry % <span class="number">10</span>);</span><br><span class="line">carry /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="built_in">get_primes</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++) &#123;</span><br><span class="line">sum[i] = <span class="built_in">get</span>(a, primes[i]) - <span class="built_in">get</span>(b, primes[i]) - <span class="built_in">get</span>(a-b, primes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++) </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j++)</span><br><span class="line">res = <span class="built_in">mul</span>(res, primes[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p>$C_n &#x3D; C_{2n}^{n} - C_{2n}^{n-1} &#x3D; \frac{C_{2n}^n}{n+1}$，可用于解决n次ab二选一，但任意前m次选a的次数不多于b的问题，如：</p><ul><li>括号匹配</li><li>栈排序</li><li>路径选择</li><li>凸多边形的三角剖分<blockquote><p>可通过平面坐标系结合几何对称性质证明</p></blockquote></li></ul><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>$$<br>\left|\bigcup_{i &#x3D; 1}^{n} A_i\right|&#x3D;\sum_{k &#x3D; 1}^{n}(-1)^{k - 1}\sum_{1\leq i_1&lt;i_2&lt;\cdots&lt;i_k\leq n} |A_{i_1}\cap A_{i_2}\cap\cdots\cap A_{i_k}|<br>$$<br>可通过该组合恒等式$\sum_{k&#x3D;0}^{r}C_r^k(-1)^{k} &#x3D; 0$证明并集的每一部分总共只被计算了一次</p><p>复杂度为$O(n2^n)$</p><p>给出n和m，以及m个素数，求出[1, n]中是该m个素数的倍数的数的数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_prime_multiple</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt; primes)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++) &#123; <span class="comment">// 不能都不选！</span></span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">p *= primes[j];</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) res += n / p;</span><br><span class="line"><span class="keyword">else</span> res -= n / p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h3><ol><li>初始设置：游戏开始时，有一堆或多堆物品。每堆中可以有不同数量的物品。</li><li>轮流行动：两名玩家轮流行动。每次行动时，玩家可以选择任意一堆物品，并从中移除一个或多个物品，但不能从多堆中同时移除物品，也不能不拿。</li><li>游戏结束：当所有物品都被移除后，游戏结束。通常，移除最后一个物品的玩家获胜，但在某些变体中，移除最后一个物品的玩家可能会输掉游戏。</li></ol><p>在n堆物品$a_1,\cdots,a_n$中，如果$a_1 ⊕ a_2 ⊕ \cdots ⊕ a_n &#x3D; 0$ ，则先手必败，否则先手必胜</p><blockquote><p>证明：</p><ol><li>$0 ⊕ 0 ⊕ \cdots ⊕ 0 &#x3D; 0$, 结束局面</li><li>$a_1 ⊕ a_2 ⊕ \cdots ⊕ a_n &#x3D; x \neq 0$，设x二进制为$x_kx_{k-1}\cdots x_1$，$x_k$显然为1，则必然存在$a_i &#x3D; a_{i,m}a_{i,m-1},\cdots ,a_{i,k}, \cdots ， a_{i, 1}$, 其中$a_{i,k}$也为1；由于$a_i \gt a_i ⊕ x$，可以从$a_i$取出$a_i - a_i ⊕ x$个物品，那么第i堆就剩下$a_i ⊕ x$个物品，使得局面变成 $a_1 ⊕ a_2 ⊕ \cdots ⊕ a_n ⊕ x &#x3D; 0$</li><li>$a_1 ⊕ a_2 ⊕ \cdots ⊕ a_n &#x3D; 0$，则无论怎么取，下个局面肯定不等于0。</li></ol></blockquote><h3 id="有向图游戏"><a href="#有向图游戏" class="headerlink" title="有向图游戏"></a>有向图游戏</h3><p>是Nim游戏的一种变种，我们先定义几个操作：</p><ul><li>Mex运算：S是一个非负整数集合，则Mex(S)表示不在S中的最小非负整数</li><li>SG函数：x是有向图中的一个节点：<ul><li>如果x出度为0，则SG(x) &#x3D; 0</li><li>否则假设x的所有后继节点为$x_1, x_2, \cdots, x_n$，$SG(x) &#x3D; Mex({SG(x_1), SG(x_2), \cdots, SG(x_n})$</li></ul></li></ul><p>有向图游戏：</p><ol><li>初始设置：游戏开始时，有若干个有向图，每个图都有一个起点。</li><li>轮流行动：两名玩家同时行动。每次行动是，玩家可以选择任意一个图，并将当前图的当前节点移动至任意一个后继节点上，但不能同时操作多个图，也不能不移动。</li><li>游戏结束：当所有图的当前节点都无法移动后，游戏结束。最后无法移动的玩家失败。</li></ol><p>设给定的n个有向图的起点为$x_1, x_2, \cdots, x_n$，则$SG(x_1) ⊕ SG(x_1) ⊕ \cdots ⊕SG(x_n) &#x3D; 0$时，先手必败，否则先手必胜。证明参考Nim游戏中的证明。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git之基本用法</title>
      <link href="/2025/01/08/Git%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2025/01/08/Git%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="git的工作目录-暂存区-版本库-远程仓库"><a href="#git的工作目录-暂存区-版本库-远程仓库" class="headerlink" title="git的工作目录|暂存区|版本库|远程仓库"></a>git的工作目录|暂存区|版本库|远程仓库</h2><ul><li><strong>工作目录</strong>：是用户在本地进行文件操作的实际目录，即项目所在的目录。用户可以在工作目录中创建、修改、删除文件等，这些操作都是在本地进行的，尚未被 Git 跟踪和管理。</li><li><strong>暂存区</strong>：也称为索引（Index），是工作目录和版本库之间的中间区域。当使用<code>git add</code>命令将文件添加到暂存区后，这些文件就准备好被提交到版本库中了。暂存区可以让用户将多次的文件修改组合成一个逻辑上的提交。</li><li><strong>版本库</strong>：也叫 Git 仓库，包含了项目的所有版本历史和相关的元数据，存储在隐藏的<code>.git</code>目录中。当执行<code>git commit</code>命令时，暂存区中的文件会被提交到版本库中，形成一个新的提交记录。</li><li><strong>远程仓库</strong>：是位于网络上的共享版本库，用于团队成员之间共享和协作开发项目。远程仓库可以是自己搭建的服务器，也可以是像 GitHub、GitLab 这样的代码托管平台上的仓库。本地仓库可以与远程仓库进行同步，将本地的提交推送到远程仓库，或者从远程仓库拉取最新的提交。</li></ul><h2 id="git的文件状态"><a href="#git的文件状态" class="headerlink" title="git的文件状态"></a>git的文件状态</h2><p>git中文件有以下常见的4种状态：未跟踪、未修改、已修改、已暂存</p><ul><li><p><strong>未跟踪（Untracked）</strong></p><ul><li><p><strong>含义</strong>：文件在工作目录中，但尚未被 Git 纳入版本控制范围，Git 不知道有这个文件的存在。</p></li><li><p><strong>场景</strong>：当在工作目录中新建一个文件，还没有执行<code>git add</code>命令将其添加到暂存区时，该文件就处于未跟踪状态。比如在项目目录下新建了一个<code>new_file.txt</code>文件，此时<code>git status</code>命令的输出会显示该文件为未跟踪文件。</p></li></ul></li><li><p><strong>已跟踪（Tracked）</strong></p><ul><li><strong>含义</strong>：文件已经被 Git 纳入版本控制，Git 会对其进行跟踪，记录文件的变更历史。已跟踪文件又可细分为以下三种状态。</li><li><strong>unmodified（未修改）</strong><ul><li><strong>含义</strong>：文件在工作目录中，且自从上次提交或更新后，其内容没有发生任何改变，与版本库中的对应版本保持一致。</li><li><strong>示例</strong>：如果项目中有一个<code>styles.css</code>文件，在上次提交后没有对其进行任何编辑操作，那么它就处于<code>unmodified</code>状态。</li></ul></li><li><strong>modified（已修改）</strong><ul><li><strong>含义</strong>：文件在工作目录中被修改了，其内容与版本库中的对应版本不一致，Git 检测到了这种变化，但这些修改还未被添加到暂存区。</li><li><strong>示例</strong>：对<code>styles.css</code>文件进行了样式调整，保存后，该文件就处于<code>modified</code>状态，<code>git status</code>命令会显示该文件被修改，提示可以选择将这些修改添加到暂存区或者丢弃。</li></ul></li><li><strong>staged（已暂存）</strong><ul><li><strong>含义</strong>：已修改的文件通过<code>git add</code>命令被添加到了暂存区，准备好被提交到版本库中，此时文件的修改会被包含在即将进行的提交中。</li><li><strong>示例</strong>：在对<code>styles.css</code>文件修改后，执行<code>git add styles.css</code>，该文件就从<code>modified</code>状态变为<code>staged</code>状态，<code>git status</code>命令会显示该文件已被暂存，等待提交。</li></ul></li></ul></li></ul><blockquote><p>以下所有操作都在实际工作目录下进行</p></blockquote><h2 id="Git本地配置"><a href="#Git本地配置" class="headerlink" title="Git本地配置"></a>Git本地配置</h2><p>在正式演示git的<strong>添加</strong>，<strong>提交</strong>，<strong>撤回</strong>等操作前，我们需要对git进行简单的配置。</p><p>Git配置分为<strong>系统</strong><code>--system</code>，<strong>全局</strong><code>--global</code>，<strong>本地</strong><code>--local</code>三个不同级别，优先级依次递减，其中如果存在重复的配置，那么低级别配置会覆盖高级别配置</p><ul><li>local配置：存在每个git仓库的<code>.git/config</code>文件中</li><li>global配置：存在用户目录下的<code>.gitconfig</code>文件中</li><li>system配置：存在<code>$&#123;profile&#125;/etc/gitconfig</code>中，<code>$&#123;prefix&#125;</code>为git的安装目录</li></ul><p>git的提交会引用用户的用户名以及邮箱(可以使用<a href="https://www.tjsky.net/tutorial/974">github提供的匿名邮箱</a>)，因此这里需要执行命令进行设置：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;DopamineNone&quot;</span><br><span class="line">git config --global user.email <span class="number">123919976</span>+DopamineNone@users.noreply.github.com</span><br></pre></td></tr></table></figure><p>相应的在配置文件中就会出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">name = DopamineNone</span><br><span class="line">email = 123919976+DopamineNone@users.noreply.github.com</span><br></pre></td></tr></table></figure><p>除此之外，还可以为git命令设置别名，比如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.ad &quot;add .&quot;</span><br></pre></td></tr></table></figure><p>相当于为<code>git add .</code>起了别名<code>git ad</code></p><h2 id="本地工作目录-暂存区-版本库操作"><a href="#本地工作目录-暂存区-版本库操作" class="headerlink" title="本地工作目录|暂存区|版本库操作"></a>本地工作目录|暂存区|版本库操作</h2><h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3><ul><li><code>git status</code>: 使用<code>git status</code>命令可以查看当前工作目录和暂存区的状态，了解哪些文件被修改、新增或删除，以及哪些文件已被暂存准备提交。</li></ul><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><ul><li><code>git log</code>可以查看版本库的提交日志</li><li>使用<code>--graph</code>选项可以查看git提交图谱</li></ul><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><ul><li><code>git init</code>: 会将当前的目录初始化化为git仓库，生成一个隐藏文件夹<code>.git</code>，用于存储与版本控制相关的信息</li></ul><p>这里实践一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br><span class="line">Initialized empty Git repository in C:/Users/DopamineNone/Projects/git_test/.git/</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>可见刚初始化后的仓库什么都没有</p><h3 id="添加至暂存区（untracked-modified-staged）"><a href="#添加至暂存区（untracked-modified-staged）" class="headerlink" title="添加至暂存区（untracked, modified -&gt; staged）"></a>添加至暂存区（untracked, modified -&gt; staged）</h3><ul><li>git add [file]<ul><li>这个操作的目的是为了将未跟踪或已修改状态的文件推至暂存区中</li><li>可以用<code>git add .</code>将仓库中<strong>所有</strong>未跟踪或已修改状态的文件推至暂存区</li></ul></li></ul><p>实践一下：</p><pre><code>1. 创建一个新文件file1.txt，查看状态(untracked)</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        file1.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><ol start="2"><li>将file1.txt推送至暂存区，查看状态(staged，这里提示词为changes to be committed，即将要提交的变化); 状态变化：untracked -&gt; staged</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   file1.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>修改file1.txt，查看状态(modified)；这里to be committed的是暂存区中file1.txt的快照；状态变化：staged -&gt; modified</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;hello git&quot;</span> &gt; file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   file1.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   file1.txt</span><br></pre></td></tr></table></figure><ol start="4"><li>将file1.txt添加至暂存区，查看状态(staged); 状态变化（modifed -&gt; staged）；状态变化：modified -&gt; staged</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add file1.txt</span></span><br><span class="line">warning: in the working copy of &#x27;file1.txt&#x27;, LF will be replaced by CRLF the next time Git touches it</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   file1.txt</span><br></pre></td></tr></table></figure><h3 id="提交暂存区文件-staged-unmodified"><a href="#提交暂存区文件-staged-unmodified" class="headerlink" title="提交暂存区文件(staged -&gt; unmodified)"></a>提交暂存区文件(staged -&gt; unmodified)</h3><p><code>git commit -m &quot;message&quot;</code>提交暂存区内容至版本库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;init project&quot;</span></span></span><br><span class="line">[master (root-commit) 1384bf0] init project</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 file1.txt</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit 1384bf0b39111d1f33ffb501f609d0c88797f422 (HEAD -&gt; master)</span><br><span class="line">Author: DopamineNone &lt;c20160419raytheon@163.com&gt;</span><br><span class="line">Date:   Wed Jan 8 13:39:46 2025 +0800</span><br><span class="line">    init project</span><br></pre></td></tr></table></figure><h3 id="查看不同区域-分支的差异"><a href="#查看不同区域-分支的差异" class="headerlink" title="查看不同区域&#x2F;分支的差异"></a>查看不同区域&#x2F;分支的差异</h3><ul><li><code>git diff</code>可以显示不同区域&#x2F;分支中的内容差异，包括</li></ul><h4 id="查看工作目录与暂存区的差异"><a href="#查看工作目录与暂存区的差异" class="headerlink" title="查看工作目录与暂存区的差异"></a>查看工作目录与暂存区的差异</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff file1.txt</span></span><br><span class="line">warning: in the working copy of &#x27;file1.txt&#x27;, LF will be replaced by CRLF the next time Git touches it</span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 8d0e412..3b18e51 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-hello git</span><br><span class="line">+hello world</span><br></pre></td></tr></table></figure><h4 id="查看暂存区与版本库的差异"><a href="#查看暂存区与版本库的差异" class="headerlink" title="查看暂存区与版本库的差异"></a>查看暂存区与版本库的差异</h4><p>需要加上选项<code>--staged</code>或<code>--cached</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add file1.txt</span></span><br><span class="line">warning: in the working copy of &#x27;file1.txt&#x27;, LF will be replaced by CRLF the next time Git touches it</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged file1.txt</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 8d0e412..3b18e51 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-hello git</span><br><span class="line">+hello world</span><br></pre></td></tr></table></figure><h4 id="查看不同提交版本间的差异"><a href="#查看不同提交版本间的差异" class="headerlink" title="查看不同提交版本间的差异"></a>查看不同提交版本间的差异</h4><p><code>git diff &lt;commit1&gt; &lt;commit2&gt;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;replace git by world&quot;</span></span></span><br><span class="line">[master 407586a] replace git by world</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit 407586abfd0b5a0239e63dc582abbd5d752edaa0 (HEAD -&gt; master)</span><br><span class="line">Author: DopamineNone &lt;xxx&gt;</span><br><span class="line">Date:   Thu Jan 9 21:05:26 2025 +0800</span><br><span class="line"></span><br><span class="line">    replace git by world</span><br><span class="line"></span><br><span class="line">commit 1384bf0b39111d1f33ffb501f609d0c88797f422</span><br><span class="line">Author: DopamineNone &lt;xxx&gt;</span><br><span class="line">Date:   Wed Jan 8 13:39:46 2025 +0800</span><br><span class="line"></span><br><span class="line">    init project</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff 407586abfd0b5a0239e63dc582abbd5d752edaa0 1384bf0b39111d1f33ffb501f609d0c88797f422</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 3b18e51..8d0e412 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-hello world</span><br><span class="line">+hello git</span><br></pre></td></tr></table></figure><h4 id="查看两个分支之间的差异"><a href="#查看两个分支之间的差异" class="headerlink" title="查看两个分支之间的差异"></a>查看两个分支之间的差异</h4><p><code>git diff &lt;branch1&gt; &lt;branch2&gt;</code>，暂不做演示</p><h3 id="撤销工作目录的修改（modified-unmodified-staged）"><a href="#撤销工作目录的修改（modified-unmodified-staged）" class="headerlink" title="撤销工作目录的修改（modified -&gt; unmodified | staged）"></a>撤销工作目录的修改（modified -&gt; unmodified | staged）</h3><p><strong>这里撤销的只是还没提交至暂存区中的修改</strong></p><ol><li>将file1.txt的内容清空，查看状态（modified）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   file1.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   file1.txt</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>git restore &lt;file&gt;</code>命令撤回修改</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   file1.txt</span><br></pre></td></tr></table></figure><h3 id="撤销暂存区的修改"><a href="#撤销暂存区的修改" class="headerlink" title="撤销暂存区的修改"></a>撤销暂存区的修改</h3><p>这里分两种情况：</p><ol><li>仅将暂存区中文件内容恢复至最近的提交版本，但不修改工作区的文件内容</li><li>将暂存区和工作区中的文件内容恢复至最近的提交中</li></ol><h4 id="仅撤销暂存区的修改"><a href="#仅撤销暂存区的修改" class="headerlink" title="仅撤销暂存区的修改"></a>仅撤销暂存区的修改</h4><p>使用<code>git reset &lt;file&gt;</code>或<code>git restore --staged &lt;file&gt;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add file1.txt</span></span><br><span class="line">warning: in the working copy of &#x27;file1.txt&#x27;, LF will be replaced by CRLF the next time Git touches it</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged file1.txt</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 3b18e51..8b13789 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-hello world</span><br><span class="line">+</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset file1.txt</span></span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       file1.txt</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff file1.txt</span></span><br><span class="line">warning: in the working copy of &#x27;file1.txt&#x27;, LF will be replaced by CRLF the next time Git touches it</span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 3b18e51..8b13789 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-hello world</span><br><span class="line">+</span><br></pre></td></tr></table></figure><h4 id="撤销工作目录和暂存区的修改"><a href="#撤销工作目录和暂存区的修改" class="headerlink" title="撤销工作目录和暂存区的修改"></a>撤销工作目录和暂存区的修改</h4><p>使用<code>git checkout HEAD &lt;file&gt;</code>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add file1.txt</span></span><br><span class="line">warning: in the working copy of &#x27;file1.txt&#x27;, LF will be replaced by CRLF the next time Git touches it</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged file1.txt</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 3b18e51..8b13789 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-hello world</span><br><span class="line">+</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout HEAD file1.txt</span></span><br><span class="line">Updated 1 path from 8242445</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff file1.txt</span></span><br></pre></td></tr></table></figure><h3 id="撤销提交记录"><a href="#撤销提交记录" class="headerlink" title="撤销提交记录"></a>撤销提交记录</h3><p>撤销提交可以由两种git命令实现: <code>git reset</code>和<code>git revert</code>，但两者的效果不同</p><p><code>git reset [option] &lt;commit&gt;</code> 分为三种情况：</p><ol><li>仅将目标版本之后commit移出，不改变暂存区和工作目录的内容</li><li>将目标版本之后commit移出，恢复暂存区内容为当前版本，但不改变工作目录内容</li><li>将版本库、暂存区、工作目录的内容恢复至目标提交版本。</li></ol><p>而<code>git revert &lt;commit&gt;</code>表示，提交一个与目标commit的效果相反的commit，从而实现仅撤回某一版本的变化的效果（例如：commit1为在之前版本上新增了func1，那么git revert commit1作用为提交一个删除了func1的commit），撤回的影响包括版本库，暂存区和工作目录</p><h4 id="仅撤销版本库提交"><a href="#仅撤销版本库提交" class="headerlink" title="仅撤销版本库提交"></a>仅撤销版本库提交</h4><p>使用<code>git reset --soft &lt;commit&gt;</code>表示撤回到哪个提交记录，如果仅撤回最近的一次提交，可以使用<code>git reset --soft HEAD~1</code>, HEAD指向本分支最新的提交，~1表示HEAD的前一次提交</p><p>下面将git记录回溯至“hello git”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit 407586abfd0b5a0239e63dc582abbd5d752edaa0 (HEAD -&gt; master)</span><br><span class="line">Author: DopamineNone &lt;xxx&gt;</span><br><span class="line">Date:   Thu Jan 9 21:05:26 2025 +0800</span><br><span class="line"></span><br><span class="line">    replace git by world</span><br><span class="line"></span><br><span class="line">commit 1384bf0b39111d1f33ffb501f609d0c88797f422</span><br><span class="line">Author: DopamineNone &lt;xxx&gt;</span><br><span class="line">Date:   Wed Jan 8 13:39:46 2025 +0800</span><br><span class="line"></span><br><span class="line">    init project</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --soft HEAD~1</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged file1.txt</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 8d0e412..3b18e51 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-hello git</span><br><span class="line">+hello world</span><br></pre></td></tr></table></figure><h4 id="仅撤销版本库提交和恢复暂存区"><a href="#仅撤销版本库提交和恢复暂存区" class="headerlink" title="仅撤销版本库提交和恢复暂存区"></a>仅撤销版本库提交和恢复暂存区</h4><p>使用<code>git reset &lt;commit&gt;</code>即可，等同于<code>git reset --mixed &lt;commit&gt;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;replace git by world 2&quot;</span></span></span><br><span class="line">[master b166262] replace git by world 2</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit b166262647db5d50e1ea59f644f59845f6fc002b (HEAD -&gt; master)</span><br><span class="line">Author: DopamineNone &lt;xxx&gt;</span><br><span class="line">Date:   Thu Jan 9 21:34:08 2025 +0800</span><br><span class="line"></span><br><span class="line">    replace git by world 2</span><br><span class="line"></span><br><span class="line">commit 1384bf0b39111d1f33ffb501f609d0c88797f422</span><br><span class="line">Author: DopamineNone &lt;xxx&gt;</span><br><span class="line">Date:   Wed Jan 8 13:39:46 2025 +0800</span><br><span class="line"></span><br><span class="line">    init project</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD~1</span></span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       file1.txt</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff file1.txt</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 8d0e412..3b18e51 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-hello git</span><br><span class="line">+hello world</span><br></pre></td></tr></table></figure><h4 id="撤销所有区域的变化至上个提交"><a href="#撤销所有区域的变化至上个提交" class="headerlink" title="撤销所有区域的变化至上个提交"></a>撤销所有区域的变化至上个提交</h4><p>使用<code>git reset --hard &lt;commit&gt;</code>，下例中工作区的内容最后也被回溯至”hello git”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;replace git by world 3&quot;</span></span></span><br><span class="line">[master e2f0737] replace git by world 3</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD~1</span></span><br><span class="line">HEAD is now at 1384bf0 init project</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> file1.txt</span></span><br><span class="line">hello git</span><br></pre></td></tr></table></figure><h4 id="仅撤回某一版本的变化"><a href="#仅撤回某一版本的变化" class="headerlink" title="仅撤回某一版本的变化"></a>仅撤回某一版本的变化</h4><p>通过<code>git revert &lt;commit1&gt;</code>实现，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot; world&quot;</span> &gt;&gt; file1.txt</span></span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> file1.txt</span></span><br><span class="line">hello git</span><br><span class="line"> world</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add file1.txt</span></span><br><span class="line">warning: in the working copy of &#x27;file1.txt&#x27;, LF will be replaced by CRLF the next time Git touches it</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;add world&quot;</span></span></span><br><span class="line">[master bc2c3ea] add world</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git revert HEAD</span></span><br><span class="line">[master a52db43] Revert &quot;add world&quot;</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit a52db43677856b9e37e880308c3581bdb53f34eb (HEAD -&gt; master)</span><br><span class="line">Author: DopamineNone &lt;xxx&gt;</span><br><span class="line">Date:   Thu Jan 9 22:38:33 2025 +0800</span><br><span class="line"></span><br><span class="line">    Revert &quot;add world&quot;</span><br><span class="line"></span><br><span class="line">    This reverts commit bc2c3ea660eea6c38d5d3c8ca03f51935a1028ec.</span><br><span class="line"></span><br><span class="line">commit bc2c3ea660eea6c38d5d3c8ca03f51935a1028ec</span><br><span class="line">Author: DopamineNone &lt;xxx&gt;</span><br><span class="line">Date:   Thu Jan 9 22:33:29 2025 +0800</span><br><span class="line"></span><br><span class="line">    add world</span><br><span class="line"></span><br><span class="line">commit 1384bf0b39111d1f33ffb501f609d0c88797f422</span><br><span class="line">Author: DopamineNone &lt;xxx&gt;</span><br><span class="line">Date:   Wed Jan 8 13:39:46 2025 +0800</span><br><span class="line"></span><br><span class="line">    init project</span><br><span class="line"></span><br><span class="line">DopamineNone@DM MINGW64 ~/Projects/git_test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> file1.txt</span></span><br><span class="line">hello git</span><br></pre></td></tr></table></figure><blockquote><p>git reset 和 git revert的区别：</p><ol><li>git reset的作用是撤回至先前的某个版本，而git revert是通过提交一个相反的commit，仅“撤回”某个版本的变化</li><li>当撤回一个公共分支（多人合作使用的分支）的某个commit时，用于公共分支的commit只增不减（若删除了公共分支的commit，会导致与其他人的本地分支产生冲突），因此这时候使用git revert最稳妥；但如果时个人分支（即该分支不会被他人直接引用），可以使用git reset 配合 git push -f实现提交撤回，并使日志更加简洁</li></ol></blockquote><p>更多git基本使用方法请见<a href="https://dopaminenone.github.io/2025/01/08/Git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(2)/">Git 基本用法(2)</a></p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tool </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-图论基础</title>
      <link href="/2024/12/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/12/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>定义图中，n为点数，m为边数</p><blockquote><p>m&#x3D; $O(n^2)$，则认为是稠密图<br>m &#x3D; $O(n)$，则认为是稀疏图</p></blockquote><h2 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h2><ul><li>邻接表，适用于稀疏图<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>邻接矩阵，适用于稠密图<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br></pre></td></tr></table></figure></li></ul><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h2><ul><li>用栈或函数递归来实现<br>朴素DFS遍历图<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> st[N], n, m;</span><br><span class="line"><span class="type">int</span> stk[N], top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (st[u]) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, u);</span><br><span class="line">st[u] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> node = h[u];</span><br><span class="line"><span class="keyword">while</span> (node != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">dfs</span>(e[node]);</span><br><span class="line">node = ne[node];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="comment">// init stack</span></span><br><span class="line">stk[top] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// pop from stack</span></span><br><span class="line"><span class="type">int</span> node = stk[top--];</span><br><span class="line">st[node] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[node]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (st[e[i]]) <span class="keyword">continue</span>;</span><br><span class="line">stk[++top] = e[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line"><span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line"><span class="comment">// build graph</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">add</span>(a,b);</span><br><span class="line"><span class="built_in">add</span>(b, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>例题：回溯&amp;剪枝， <a href="https://leetcode.cn/problems/permutations/">Leetcode 46. 全排列</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; visited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">        tmp.<span class="built_in">clear</span>();</span><br><span class="line">        visited.<span class="built_in">assign</span>(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">helper</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件判断</span></span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 枚举</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">helper</span>(nums);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="宽度优先搜索-BFS"><a href="#宽度优先搜索-BFS" class="headerlink" title="宽度优先搜索 BFS"></a>宽度优先搜索 BFS</h2><ul><li>用队列实现</li></ul><p>走迷宫（最短路）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> maze[N][N];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line">pii q[N*N];</span><br><span class="line"><span class="type">int</span> n, m, hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q[tt++] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> , <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt; tt) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + dx[i] &gt;= <span class="number">0</span> &amp;&amp; x + dx[i] &lt; n </span><br><span class="line">            &amp;&amp; y + dy[i] &gt;= <span class="number">0</span> &amp;&amp; y + dy[i] &lt; m </span><br><span class="line">            &amp;&amp; maze[x+dx[i]][y+dy[i]] == <span class="number">0</span> </span><br><span class="line">            &amp;&amp; d[x+dx[i]][y+dy[i]] == <span class="number">-1</span>) &#123;</span><br><span class="line">                d[x+dx[i]][y+dy[i]] = d[x][y] + <span class="number">1</span>;</span><br><span class="line">                q[tt++] = &#123;x+dx[i], y+dy[i]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;maze[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">bfs</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>数据结构</th><th>空间</th><th>特点</th></tr></thead><tbody><tr><td>DFS</td><td>栈</td><td>O(h)</td><td>不具有最短性</td></tr><tr><td>BFS</td><td>队列</td><td>$O(2^h)$</td><td>最短路</td></tr></tbody></table><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>有向无环图的拓扑排序通过实时计算每个点的出度入度来实现</p><ul><li>出度：该节点直接连接到其他点的路径数</li><li>入度：其他点直接到该点的路径数<blockquote><p>有向无环图必然存在入度为0的点</p></blockquote></li></ul><p>思路：</p><ol><li>找出所有入度为0的点，加入队列</li><li>每从队列取出一个点a，便打印该点，标记为已经遍历，并遍历它的所有出边(a -&gt; b)，将b的入度减一；若b的入度变为0，则将b节点加入队列</li><li>重复步骤2，至队列为空<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], d[N],idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[idx] = v, ne[idx] = h[u], h[u] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find in-degree</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (d[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// topological sort</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            d[j]--;</span><br><span class="line">            <span class="keyword">if</span> (d[j] == <span class="number">0</span>) q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>例题：<a href="https://www.marscode.cn/practice/8el75d11djy843?problem_id=7414004855076503596">MarsCode, 94.数据表是否能顺利产出</a></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">265</span>;</span><br><span class="line"><span class="type">int</span> h[<span class="number">26</span>], e[N], ne[N], idx, in[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getIndex</span><span class="params">(string x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="number">26</span>);</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[idx] = v;</span><br><span class="line">    ne[idx] = h[u];</span><br><span class="line">    h[u] = idx++;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solution</span><span class="params">(<span class="type">const</span> std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; relations)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">reset</span>();</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; arr : relations) &#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">getIndex</span>(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">getIndex</span>(arr[i]);</span><br><span class="line">            <span class="built_in">add</span>(h, x);</span><br><span class="line">            in[x]++;</span><br><span class="line">            table.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span> (in[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> top = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[top]; ~i; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--in[e[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">                table.<span class="built_in">erase</span>(e[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> table.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><h3 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h3><h4 id="边权为正"><a href="#边权为正" class="headerlink" title="边权为正"></a>边权为正</h4><ul><li>朴素Dijkstra算法（O(n^2)），适用于稠密图</li><li>堆优化版Dijkstra算法(O(mlogn))，适用于稀疏图</li></ul><h5 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h5><p>步骤：</p><ol><li>找到当前距离源点最近的点N</li><li>标记访问</li><li>更新以N为中介的源点到其他点的最短距离<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// find shortest path</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; (t == <span class="number">-1</span> || dis[j] &lt; dis[t])) t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mark visited</span></span><br><span class="line">        vis[t] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update distance</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) </span><br><span class="line">            <span class="keyword">if</span> (g[t][k] != <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">                dis[k] = <span class="built_in">min</span>(dis[k], dis[t] + g[t][k]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], w[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pii&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pii u = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[u.second]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u.second] = <span class="number">1</span>;</span><br><span class="line">        dis[u.second] = u.first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新距离/ 松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[u.second]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[e[i]] &gt; u.first + w[i]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;u.first + w[i], e[i]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度解释：</p><ol><li>优先队列操作：图中每个边最多被添加或删除一次，故为$O(mlogn)$</li><li>遍历边操作：在遍历每条边时，可能会更新邻居节点的距离，并将其插入优先队列，总时间复杂度是 $O(mlogn)$<br>故总复杂度应该是$O(mlogn)$</li></ol><h4 id="边权可为负"><a href="#边权可为负" class="headerlink" title="边权可为负"></a>边权可为负</h4><p>边权可为负的图中，若存在<strong>负权回路</strong>，则<strong>与源点间存在经过负环的路径的节点</strong>不存在最短路</p><ul><li>Bellman-Ford(O(nm))</li><li>SPFA(O(m), 最坏O(nm))</li></ul><h5 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h5><ul><li>可以找出负环（鸽巢原理）</li><li>结果满足三角不等式$dist[b] \le dist[a] + w$</li><li>图中允许存在负环</li><li>可以解决限制经过边数的最短路问题<br>算法思路：循环n次，每次遍历所有边，并更新每个点到源点的距离<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存边即可</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125; E[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> backup[N];</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回到第n点的最多经过k段的最短距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dis, <span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="type">int</span> a = E[j].a, b = E[j].b, w = E[j].w;</span><br><span class="line">            <span class="keyword">if</span> (backup[a] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dis[b] = <span class="built_in">min</span>(backup[b], backup[a] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h5><ul><li>可以判断负环是否存在 (鸽巢原理)</li><li>效率比bellman_ford高<br>思路：初始化队列，队列初始只有一个源点；之后不断迭代，每从队列头取出一个节点，就跟新它的所有出边，并将邻居节点加入队列，直至队列为空<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], w[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dis[N], cnt[N], vis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[e[i]] &gt; dis[u] + w[i]) &#123;</span><br><span class="line">                <span class="comment">// 判断是否存在负环</span></span><br><span class="line"><span class="keyword">if</span> ((cnt[e[i]] = cnt[u] + <span class="number">1</span>) &gt;= n) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line">                dis[e[i]] = dis[u] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e[i]]) &#123;</span><br><span class="line">                    vis[e[i]] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="多源最短路-Floyd"><a href="#多源最短路-Floyd" class="headerlink" title="多源最短路 Floyd"></a>多源最短路 Floyd</h3><ul><li>Floyd算法($O(n^3)$)</li><li>不能处理具有负环的图<br>思路：依次选择一个点为中转点，计算每两个点之间的最短路<br>归纳证明：$d[k, i, j] &#x3D; min(d[k-1, i, j], d[k-1, i, k] + d[k-1, k, j])$，其中$d[k-1,i,j]$表示从顶点i到顶点j，且中间顶点仅取自${1,2,…,m-1}$的最短路长度<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[i][k] == INF || d[k][j] == INF) <span class="keyword">continue</span>;</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><blockquote><p>最小生成树问题一般针对无向图</p></blockquote><p>最小生成树算法有两个：</p><ul><li>Prim算法</li><li>Kruskal算法<br>两者都是基于贪心的思想</li></ul><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>与Dijkstra算法非常想，也有朴素版（$O(n^2)$）和堆优化版（$O(mlogn)$），分别适用于稠密图和稀疏图。这里仅介绍<strong>朴素版</strong>。</p><p>思路：</p><ol><li>初始化生成树集合，所有点到该集合的距离设为无穷</li><li>找到集合外随便一点，加入集合，并以该点更新其他店到集合的距离</li><li>进行N-1次循环，每次循环找到集合最短的出边，并将对应的点加入集合，且以新加入的点更新集合外其他点到集合的距离</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N], dist[N], st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"><span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">t = j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="comment">// 先累加再更新距离，避免自环</span></span><br><span class="line"><span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">st[t] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>复杂度为$O(mlogm)$，适用于稀疏图，与Prim堆优化版算法更推荐Kruskal算法。</p><blockquote><p>同$O(mlogn)$, 因为$m \le n^2$</p></blockquote><p>思路：</p><ol><li>初始化生成树集合，为空</li><li>将所有边按权重从小到大排序 $O(mlogm)$</li><li>依次枚举每条边a-b：$O(m)$<ul><li>if a-b不连通（指在集合中，可用并查集进行判断），则将边ab加入集合</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge&amp; e) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        e[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init disjoint set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = e[i].u, v = e[i].v;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(u), b = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            ans += e[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n<span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>定义：一个图的所有顶点，可以把所有顶点分为两个顶点集合，每个集合中两两不直接相连。</p><blockquote><p>一个图是二分图，<strong>当且仅当</strong>图中不含奇数环</p></blockquote><p>二分图相关的算法有两个：</p><ul><li>染色法</li><li>匈牙利算法</li></ul><h3 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h3><p>该算法可以判断一个图是否为二分图，复杂度为$O(n+m)$</p><p>思路：DFS遍历每个点，是每相邻两个点分到不同集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], color[N], idx = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// color: 0: uncolored, 1: red, 2: blue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!color[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>)) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>该算法可以解决<strong>二分图最大匹配问题</strong>，复杂度为$O(mn)$，实际运行时间远小于$O(mn)$</p><blockquote><p>匹配是指一组边的集合，其中任意两条边都没有共同的顶点。</p></blockquote><p>思路：</p><ol><li>将二分图的点分为两个点集AB，保存A到B的路径信息</li><li>遍历A的每个点a，遍历连接a的点b<ul><li>如果b还没被匹配，使a匹配b，并记录match[b] &#x3D; a</li><li>如果b被匹配，则尝试使match[b]匹配其他节点（），如果成功则记录match[b] &#x3D; a，否则a无法找到匹配</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n1, n2, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!match[j] || <span class="built_in">find</span>(match[j])) &#123;</span><br><span class="line">                match[j] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis底层中的数据结构</title>
      <link href="/2024/09/05/Redis%E5%BA%95%E5%B1%82%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/09/05/Redis%E5%BA%95%E5%B1%82%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>简单动态字符串（Simple Dynamic String），与C字符串不同。SDS结构体字典如下：</p><ul><li>buf 保存SDS的字符数据的字符数组</li><li>len，已保存的字符串长度（字节数），结尾的’\0’字符不算在len中</li><li>alloc, 预分配空间大小</li><li>flags, SDS的头类型，控制SDS头大小</li></ul><p>与C的区别：</p><ul><li>常数复杂度获取字符串长度</li><li>自动分配内存，杜绝缓冲区溢出且减少分配内存次数<ul><li>空间预分配<ul><li>修改后的字符串长度len&lt;1MB，会分配2*len+1byte的空间</li><li>修改后的字符串长度len&gt;&#x3D;1MB，会分配len+1MB+1byte的空间</li></ul></li><li>惰性空间释放<ul><li>进行字符串缩短操作后并不会马上释放空闲空间</li></ul></li></ul></li><li>二进制安全<ul><li>无视’\0’等特殊字符串的影响，使得SDS可以保存任意二进制数据</li></ul></li></ul><h2 id="IntSet"><a href="#IntSet" class="headerlink" title="IntSet"></a>IntSet</h2><p>整型集合（Int Set)，<strong>有序</strong>，长度可变。结构体字段如下：</p><ul><li>encoding 编码方式（16，32，64）</li><li>length 元素个数</li><li>contents 字节数组，保存集合数据</li></ul><p>当新添加的元素大小超过现集合的编码类型表示的数值范围，IntSet会自动<strong>升级</strong>至合适的编码方式。过程：</p><ul><li>扩容数组</li><li>倒序拷贝：将现有元素拷贝到正确的位置</li><li>添加新元素</li></ul><blockquote><p>IntSet不支持降级</p></blockquote><h2 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h2><p>字典（Dict），一种用于保存键值对的数据结构。由三部分组成：</p><ul><li>哈希表</li><li>哈希节点</li><li>字典</li></ul><p>哈希表dictht结构体字段：</p><ul><li>table 指向entry的指针</li><li>size，哈希表大小，总是等于$2^n$</li><li>sizemask，哈希表大小的掩码，总等于size-1</li><li>used entry的个数</li></ul><p>哈希节点dictEntry结构体字段：</p><ul><li>key 键</li><li>v 值</li><li>next 指向下一个entry的指针（解决哈希冲突）</li></ul><p>字典结构体字段：</p><ul><li>type dict类型，内置不同hash函数</li><li>privdata 私有数据，在做特殊hash运算时使用</li><li>dictht ht[2] 一个字段包含两个哈希表，一个是当前数据，另一个为空，rehash时使用</li><li>rehashidx rehash进度，-1表示未进行</li><li>pauserehash rehash是否暂停，1则暂停</li></ul><h3 id="存取过程"><a href="#存取过程" class="headerlink" title="存取过程"></a>存取过程</h3><p>对键值key调用哈希函数<code>dict-&gt;type-&gt;hashFunction(key)</code>得到哈希值hash，再通过hash &amp; sizemask得到哈希表的索引位置。插入时若该索引上已有哈希节点，则用<strong>头插法</strong>把新键值插入链表上。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>当哈希表保存的键值对数量太多时，必然导致哈希冲突增多，链表过长，查询效率降低，因此需要rehash进行dict扩容。扩容后必须对哈希表的每个key重新计算索引，插入新哈希表，这个过程就是<strong>rehash</strong>。</p><p>哈希表扩容条件与<strong>负载因子</strong>（LoadFactor &#x3D; used &#x2F; size）有关:</p><ul><li>LoadFactor &gt;&#x3D; 1, 并且服务器没有执行BGSAVE或BGREWRITEAOF等后台进程</li><li>LoadFactor &gt; 5</li></ul><p>类似的，当LoadFactor&lt;0.1时，就会触发哈希表收缩。</p><p>rehash过程：</p><ul><li>计算新哈希表的size</li><li>申请新的dictht, 赋值给dict.ht[1]</li><li>dict.rehashidx&#x3D;0，表示开始rehash</li><li>将dict.ht[0]的每个entry进行rehash，保存到dict.ht[1]</li><li>将dict.ht[1]赋值到dict.ht[0]，dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]内存</li></ul><blockquote><ul><li>redis中解决哈希冲突使用的是<strong>链地址法</strong></li><li>因为哈希表大小size总是$2^n$，所以 hash &amp; sizemask &#x3D;&#x3D; hash % size</li><li>BGSAVE或BGREWRITEAOF执行时，Redis会fork子进程，由因为linux等操作系统采用写时复制（copy on write），所以将扩容所需的LoadFactor提高，避免不必要的内存写入操作，最大限度节约内存</li><li>rehash是分<strong>多次渐进式</strong>完成的:rehashidx设为0后，每次对字典执行增删改查式，就会将ht[0]韩信表在rehashidx索引上的所有键值对rehash到ht[1]，并且rehashidx++；删改查等操作会在两个哈希表依次进行，新增操作直接在ht[1]上执行。</li></ul></blockquote><h2 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h2><p> 压缩链表（Zip List），与双端链表类似，但不是通过指针连接，是实现列表键和哈希键的基础。结构体字段如下：</p><ul><li>zlbytes 结构体总字节数</li><li>zltail 尾偏移量，为链表尾节点距离压缩链表启示地址的字节数</li><li>zllen entry 节点个数，最大值为UINT16_MAX</li><li>entryX，列表节点，长度不定</li><li>zlend 为定值0xFF,用于表级列表末端</li></ul><p>Entry字段：</p><ul><li>previous_entry_length：前一节点长度len<ul><li>如果len &lt; 254, 该字段只占1字节</li><li>如果len &gt;&#x3D; 254, 该字段占5字节，第一字节为0xFE, 后四个字节才是正事长度数据</li></ul></li><li>encoding：编码属性，记录content的数据类型以及长度<ul><li>最高位以‘00’ ‘01‘ ’10’开头表明contents为字符串&#x2F;字符数组；‘00’时encoding只占1字节，剩余位数表示contents字节长度；‘01’时encoding只占两字节，剩余位数表示contents字节长度; ‘10’时encoding占5字节，其中后四字节才表示contents字节长度</li><li>最高位以‘11‘开头表明contents为整数，encoding只占1字节，剩余位数表示不同的整数类型。<strong>值得注意的是</strong>，若encoding为’1111xxxx’，则该entry没有contents, 值为xxxx</li></ul></li><li>contents: 保存节点数据，可以是字符串或整数</li></ul><h3 id="连锁更新问题"><a href="#连锁更新问题" class="headerlink" title="连锁更新问题"></a>连锁更新问题</h3><p>连锁更新问题是压缩链表中发生概率较低的一种问题。假设当前链表所有entry字节长度都是250~253字节，某一时刻在链表头部插入一个长度超过253的entry，导致原来所有的entry的prevous_entry_length所占空间由1字节转化为5字节，发生频繁的内存扩容申请导致性能损耗较高。</p><blockquote><p>ZipList虽然节省空间，但由于内存必须是连续空间，占用内存过多时申请内存效率很低。</p></blockquote><h2 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h2><p>是一个双端链表，但链表中每个节点都是一个ZipList</p><p>Redis提供了一些配置项：</p><ul><li><code>list-max-ziplist-size</code>来限制QuickList中每个ZipList的节点数量过多</li><li><code>list-compress-depth</code>来控制对节点的压缩深度；0时代表所有节点不压缩，1时表示首尾各一个节点不压缩；</li></ul><p><img src="/./pics/image-20240905154113904.png" alt="image-20240905154113904"></p><h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><p>跳表（Skip List)，是一种链表，是有序集合的底层实现之一，有以下特点：</p><ul><li>元素按升序排列存储</li><li>节点可以包含多个指针，指针跨度不同</li></ul><p>跳表结构体字段如下：</p><ul><li>header 跳表头节点</li><li>tail 跳表尾节点</li><li>level 跳表内最大的层数（不考虑表头节点的层数）</li><li>length</li></ul><p>跳表节点结构体字段如下：</p><ul><li>level[]<ul><li>forward 前进指针</li><li>span 指针跨度，记录两节点的距离</li></ul></li><li>backward 后退指针</li><li>score 分值</li><li>obj redis对象</li></ul><p>查询过程：</p><ol><li><strong>从最高层开始</strong>：查询操作总是从跳表的最高层开始，因为这一层的节点数量最少，可以最快地跨越较大的距离。</li><li><strong>向前移动</strong>：在当前层级，比较目标值与当前节点的值。如果目标值小于当前节点的值，则向后退一步（如果可能的话），移动到当前节点的前一个节点；如果目标值大于当前节点的值，则尝试向右移动到下一个节点。</li><li><strong>向下移动</strong>：如果当前层级已经没有更多的节点可以向右移动，那么就向下移动到下一层的相同位置继续查找。</li><li><strong>重复步骤</strong>：重复上述步骤，直到找到匹配的目标值或达到最低层且无法再向右移动为止。</li></ol><blockquote><ul><li>每个节点的层高是1至32的随机数</li></ul></blockquote><h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><p>Redis中任意数据类型都会封装为一个RedisObject，结构体字段如下：</p><ul><li>unsigned type，记录对象类型<ul><li>REDIS_STRING</li><li>REDIS_LIST</li><li>REDIS_HASH</li><li>REDIS_SET</li><li>REDIS_ZSET</li></ul></li><li>usigned encoding，记录对象所使用的编码（底层数据结构），包括上述的数据结构</li><li>void *ptr 指向底层实现数据结构的指针</li><li>int refcount 记录对象的计数信息，用于内存回收和对象共享</li><li>usigned lru 记录对象最后一次被命令查询访问的时间，可用于内存回收</li></ul><p><img src="/./pics/image-20240905152255669.png" alt="image-20240905152255669"></p><p>可以使用<code>TYPE</code>命令查看一个键对应的值对象类型，<code>OBJECT ENCODING</code>查看底层使用的编码方式</p><blockquote><ul><li>Redis执行命令前会检查给定键的类型能否执行指定命令，并检查编码来觉得执行命令的方法&#x2F;函数</li><li>Redis共享0到9999的字符串对象</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之日志</title>
      <link href="/2024/08/29/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97/"/>
      <url>/2024/08/29/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p>错误日志记录了MySQL启动和停止时，服务器运行过程发生的错误相关信息；该日志默认开启。</p><p>查看日志位置，一般位于<code>/var/log</code>下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><p>BINLOG，记录了所有DDL和DML</p><p>作用：</p><ul><li>灾难时的数据恢复</li><li>MySQL的主从复制</li></ul><p>MySQL8中二级制日志默认开启</p><p>查看日志位置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span></span><br></pre></td></tr></table></figure><p>日志格式：</p><ul><li>STATEMENT<ul><li>基于SQL语句的记录</li></ul></li><li>ROW<ul><li>基于行的日志记录，记录每行的数据变更</li></ul></li><li>MIXED<ul><li>混合STATEMENT和ROW</li></ul></li></ul><p>查看格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可在MySQL配置文件使用<code>binlog_format=xxx</code>指定日志格式</p><p>查看binlog需要使用<code>mysqlbinlog</code>来查看，具体语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [<span class="operator">-</span>arguments] logfile</span><br></pre></td></tr></table></figure><p>清理日志：</p><ul><li><code>restart master</code> 删除所有binlog</li><li><code>purge master logs to &#39;binlog.****&#39;</code> 删除***编号之前的所有日志</li><li><code>purge master logs before &#39;yyyy-mm-dd hh:mi:ss&#39;</code>删除指定时间之前产生的日志</li></ul><h2 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h2><p>记录客户端所有的操作语句</p><p>查看日志参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span></span><br></pre></td></tr></table></figure><p>在MySQL配置文件指定<code>general_log=1</code>开启查询日志，<code>general_log_file=xxx</code>指定日志路径</p><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>记录了所有执行时间超过参数long_query_time并扫描记录不小于min_examined_row_limit的所有SQL语句日志</p><p>在MySQL配置文件指定<code>slow_query_log=1</code>开启日志，<code>long_query_time=xxx</code>指定执行时间</p><p>默认不会记录管理语句，也不会记录不使用所有进行查找的查询，在MySQL配置文件指定<code>log_slow_admin_statements</code>开启日志，<code>log_queries_not_using_indexes</code>指定执行时间</p><p>查看日志位置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span>  <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Ops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之InnoDB引擎</title>
      <link href="/2024/08/28/MySQL%E4%B9%8BInnoDB%E5%BC%95%E6%93%8E/"/>
      <url>/2024/08/28/MySQL%E4%B9%8BInnoDB%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><ul><li>TableSpace 表空间<ul><li>ibd文件，一个mysql实例可以对应多个表空间，用于存储记录、索引等数据</li></ul></li><li>Segment 段<ul><li>分为数据段、索引段、回滚段，InnoDB是索引组织表，数据段就是B+树的叶子节点，索引是B+树的非叶子节点。</li></ul></li><li>Extent<ul><li>区，表空间的单元结构，每个区大小为1M</li></ul></li><li>Page<ul><li>页，InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB，为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区</li></ul></li><li>Row<ul><li>行</li></ul></li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><p>执行增删改操作时，先操作缓冲池数据；若没有数据，则从磁盘加载并缓存；然后再以一定频率刷新到磁盘从而减少磁盘IO</p><p>缓存池以Page为单位，用链表管理Page。</p><ul><li>free page 即空闲Page</li><li>clean page 被使用但违背修改过的page</li><li>dirty page 脏页，数据被修改过，可能与磁盘数据不一致</li></ul><h4 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h4><p>更改缓冲区，针对非谓唯一二级索引页，在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而回将数据变更至Change Buffer中。在未来数据被读取时，数据再合并恢复到Buffer Pool中，再将数据刷到磁盘中。</p><blockquote><p>意义：</p><ul><li>减少磁盘I&#x2F;O操作</li><li>提高写入效率</li></ul></blockquote><h4 id="Adaptive-Hash-Index"><a href="#Adaptive-Hash-Index" class="headerlink" title="Adaptive Hash Index"></a>Adaptive Hash Index</h4><p>自适应hash索引，用于优化对Buffer Pool数据的查询。无需人工干预，是系统根据情况自动完成。</p><p>查看是否开启：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%hash_index%&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h4><p>日志缓冲区，保存redo log, undo log数据。日志缓冲区的日志回定期刷新到磁盘中。</p><p>innodb_log_buffer_size: 缓冲区大小</p><p>innodb_flush_log_at_trx_commit: 日志刷新到磁盘时机</p><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><h4 id="System-Tablespace"><a href="#System-Tablespace" class="headerlink" title="System Tablespace"></a>System Tablespace</h4><p>更改缓冲区的存储区域。</p><p>参数：<code>innodb_data_file_path</code></p><h4 id="File-Per-Table-Tablespaces"><a href="#File-Per-Table-Tablespaces" class="headerlink" title="File-Per-Table Tablespaces"></a>File-Per-Table Tablespaces</h4><p>每个表的文件表空间包括单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件(<code>.ibd</code>)</p><p>参数：<code>innodb_file_per_table</code></p><h4 id="General-Tablespaces"><a href="#General-Tablespaces" class="headerlink" title="General Tablespaces"></a>General Tablespaces</h4><p>通用表空间，需要通过CREATE TABLESPACE语法创建通用表空间，在创建表时，可以指定该表空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>space space_name <span class="keyword">add</span> datafile <span class="string">&#x27;xxx.ibd&#x27;</span> engine <span class="operator">=</span> innodb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> xxx (</span><br><span class="line">...</span><br><span class="line">) engine<span class="operator">=</span>innodb tablespace space_name;</span><br></pre></td></tr></table></figure><h4 id="Undo-Tablespaces"><a href="#Undo-Tablespaces" class="headerlink" title="Undo Tablespaces"></a>Undo Tablespaces</h4><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间，用于存储undo log</p><h4 id="Temporary-Tablespaces"><a href="#Temporary-Tablespaces" class="headerlink" title="Temporary Tablespaces"></a>Temporary Tablespaces</h4><p>存储临时表</p><h4 id="Doublewrite-Buffer-Files"><a href="#Doublewrite-Buffer-Files" class="headerlink" title="Doublewrite Buffer Files"></a>Doublewrite Buffer Files</h4><p>双写缓冲区，innodb从buffer pool刷新到磁盘前，写将数据页写入双写缓冲区文件，用于系统异常时恢复数据(<code>.dblwr</code>)</p><h4 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h4><p>实现事务持久性，又重做日志缓冲区和重做日志文件组成。事务提交后会把所有修改信息都存在日志中。</p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>作用：在合适的时机将数据刷新到磁盘中</p><ul><li>Master Thread<ul><li>负责将缓冲区数据异步刷新到磁盘中，保持数据一致性；脏页刷新，合并插入缓存，undo页回收</li></ul></li><li>IO Thread<ul><li>Read thread</li><li>Write thread</li><li>Log thread 日志缓冲区刷入磁盘</li><li>Insert buffer thread 写缓冲区刷入磁盘</li></ul></li><li>Purge Thread<ul><li>回收事务已经提交的undo log</li></ul></li><li>Page Cleaner Thread<ul><li>协助Master Thread刷新脏页到磁盘的线程</li></ul></li></ul><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>不可分割的工作单位，事务的所有操作要么同时成功，要么同时失败</p><p>特点：ACID</p><blockquote><p>原子性、一致性、持久性由redo log、undo log保证， 隔离性由锁、MVCC保证</p></blockquote><h3 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h3><p>重做日志由重做日志缓冲以及重做日志文件组成，前者在内存中，后缀在磁盘中。</p><h3 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h3><p>回滚日志，记录数据被修改前的信息。作用：提供回滚和MVCC</p><p>undo log是逻辑日志，记录与当前操作效果相反的记录。</p><p>undo log在事务提交后，并不会删除undo log，这些日志可能会用在MVCC</p><p>undo log采用段的方式进行管理和记录，存放在rollback segment回滚段</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul><li>当前读</li></ul><p>读取的记录是最新版本，且要保证其他并发事务不能修改当前记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">update</span></span><br><span class="line"><span class="keyword">insert</span></span><br><span class="line"><span class="keyword">delete</span></span><br></pre></td></tr></table></figure><ul><li>快照读</li></ul><p>简单的select就是快照读，读取的是记录数据的可见版本</p><ul><li><p>Read Committed 每次select都会生成一个快照读</p></li><li><p>Repeatable Read 开启事务后第一个select语句才是快照读的地方</p></li><li><p>Serializable 快照读会退化为当前读</p></li><li><p>MVCC</p></li></ul><p>全程：多版本并发控制，指维护一个数据的多个版本，是读写操作没有冲突。</p><p>MVCC具体实现依赖于数据库记录的三个隐式字段、undo log日志、readView</p><h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><ul><li><code>DB_TRX_ID</code> 最近改动事务ID，记录插入这条记录或最后一次修改该记录的事务ID</li><li><code>DB_ROLL_PTR</code>回滚指针，指向这条记录的上一个版本</li><li><code>DB_ROW_ID</code> 如果表结构没有主键，将会生成该隐藏字段</li></ul><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>当insert的时候，产生的undo log日志只在回滚是需要，事务提交后可以立即删除</p><p>而update、delete的时候，产生的undo log日志不仅在回滚需要，快照读时也需要</p><p>对同一事务的修改会导致undolog生成一条记录版本链表，头部时最新的旧记录，尾部是最早的旧记录</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>是快照读SQL指向时MVCC提取数据的依据</p><p>四个字段：</p><ul><li>m_ids 当前活跃事务ID集合&#x2F;尚未提交的事务ID集合</li><li>min_trx_id 最小活跃事务ID&#x2F;尚未提交的事务ID值</li><li>max_trx_id 预分配事务ID&#x2F;下次要生成的事务ID值</li><li>creator_trx_id ReadView创建者的事务ID</li></ul><p>规则：</p><p><img src="/./pics/image-20240828150848272.png" alt="image-20240828150848272"></p><ul><li>RC隔离级别下，在事务中每一次执行快照读时生成ReadView</li><li>RR隔离级别下，每一个事务最多生成一次ReadView</li></ul><p>关于事务、MVCC，这里推荐一个介绍视频：<a href="https://www.bilibili.com/video/BV1FW421d7DA/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=dd291d3bf50e92741817346c92c84f80">面试官：你怎么理解MySQL事务和MVCC的？</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之锁</title>
      <link href="/2024/08/28/MySQL%E4%B9%8B%E9%94%81/"/>
      <url>/2024/08/28/MySQL%E4%B9%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>锁是计算机协调多进程&#x2F;线程访问临界资源的机制。MySQL中，按锁的的粒度可分为三类锁：</p><ul><li>全局锁：数据库中所有表</li><li>表级锁：每次操作锁整张表</li><li>行级锁：每次操作锁相应的行</li></ul><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>加锁后整个实例处于只读状态。</p><p>应用场景：全库的逻辑备份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加全局锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 备份数据</span></span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p your_database <span class="operator">&gt;</span> xxx.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p>存在的问题：</p><ul><li>主库备份：备份期间业务停摆</li><li>从库备份：不能执行主库同步过来的binlog，导致主从延迟</li></ul><p>故推荐用参数<code>--single-transaction</code>代替全局锁完成一致性数据备份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction ...</span></span><br></pre></td></tr></table></figure><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁又分为：</p><ul><li>表锁<ul><li>表共享读锁</li><li>表独占写锁</li></ul></li><li>元数据锁</li><li>意向锁</li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加锁</span></span><br><span class="line">lock tables table_name [read<span class="operator">|</span>write];</span><br><span class="line"><span class="comment">-- 释放锁</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p>表共享读锁, 表独占写锁与Golang的读写锁<code>sync.RWMutex</code>概念类似</p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>meta data lock(MDL), 加锁过程由系统自动控制，MDL锁主要作用是维护元数据的一致性；避免DML和DDL冲突，保证读写正确性。</p><p><img src="/./pics/image-20240828090653972.png" alt="image-20240828090653972"></p><p>查看当前数据库使用的元素据锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_type, object_schema, object_name, lock_type, lock_duration <span class="keyword">from</span> performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>作用：避免DML加的行锁和表锁的冲突；使用意向锁来减少表锁的检查;也是系统自动追加的锁。</p><ul><li><p>防止死锁和冲突：通过使用意向锁，系统可以更好地协调不同事务之间的并发操作，避免出现死锁情况。</p></li><li><p>提供锁升级路径：意向锁允许从较低级别的锁（如行级锁）升级到更高级别（如表级锁），而无需释放所有较低级别的锁再重新加锁。</p></li><li><p>意向共享锁（IS）：读锁兼容，写锁互斥</p></li><li><p>意向排他锁（IX）：读写锁都互斥</p></li></ul><p>查看意向锁和行锁情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema, object_name, index_name, lock_type, lock_mode, lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>锁定粒度最小，并发度最高。</p><p>行锁是通过索引上的索引项加锁来实现的，而不是对记录加的锁。</p><p>InnoDB下行级锁又分为三类：</p><ul><li>行锁： 锁定单个行记录的锁，防止其他事务对此进行update和delete</li><li>间隙锁：锁定索引记录间隙，防止其他事务在足够间隙进行insert，产生幻读</li><li>临键锁：行锁和间隙锁的组合</li></ul><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul><li>共享锁（S）</li><li>排他锁（X）</li></ul><p><img src="/./pics/image-20240828093124913.png" alt="image-20240828093124913"></p><ul><li>针对唯一索引进行检索，对已存在的记录进行等值匹配，将会自动优化为行锁。</li><li>InnoDB的行锁是针对索引加的锁，不通过索引条件检索数据则InnoDB将对表中的所有记录加锁，即升级为表锁</li></ul><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>REPEATABLE READ事务隔离级别下，InnoDB使用next-keys锁进行搜索和索引扫描，防止幻读</p><ul><li>对索引上的等值查询（唯一索引），给不存在的记录加锁，优化为间隙锁</li><li>对索引上的等值查询（普通索引），向右遍历最后一个值不满足查询需求时，next-key lock退化为间隙锁</li><li>对索引上的范围查询（唯一索引），回访问到不满足条件的第一个值为止</li></ul><h3 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h3><p>行锁+间隙锁</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之存储过程&amp;函数&amp;触发器</title>
      <link href="/2024/08/27/MySQL%E4%B9%8B%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B&amp;%E5%87%BD%E6%95%B0&amp;%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2024/08/27/MySQL%E4%B9%8B%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B&amp;%E5%87%BD%E6%95%B0&amp;%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程是实现经过编译并存储在数据库中的一段SQL语句的集合，即实现了SQL代码的封装与重用</p><p>特点：</p><ul><li>封装、复用</li><li>可以接收参数，也可以返回数据</li><li>减少网络交互，效率提升</li></ul><h3 id="存储过程的使用"><a href="#存储过程的使用" class="headerlink" title="存储过程的使用"></a>存储过程的使用</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> procedure_name([参数列表])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- sql</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><blockquote><p>命令行中创建存储过程需要通过delimiter指定SQL语句的结束符</p></blockquote><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> procedure_name (arguments...)</span><br></pre></td></tr></table></figure><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看指定数据库的存储过程</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.ROUTINES <span class="keyword">where</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;database_name&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看创建存储过程的sql语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> procedure_name;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> procedure_name;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p>MySQL提供了一些系统变量，分为<strong>全局变量</strong>和<strong>会话变量</strong></p><h5 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables;<span class="comment">-- 查看所有系统变量</span></span><br><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables <span class="keyword">like</span> <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> @@[session<span class="operator">|</span><span class="keyword">global</span>].系统变量名;</span><br></pre></td></tr></table></figure><h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> [session<span class="operator">|</span><span class="keyword">global</span>] variable_name <span class="operator">=</span> <span class="string">&#x27;...&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>重启MySQL后，全局变量会恢复为配置文件中设置的默认值</p></blockquote><h4 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h4><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@variable</span> <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@variable</span> :<span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>; <span class="comment">-- 推荐，用于区分赋值和等于</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@variable</span> :<span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> column_a <span class="keyword">into</span> <span class="variable">@variable</span> <span class="keyword">from</span> table_name ...;</span><br></pre></td></tr></table></figure><h5 id="查看-2"><a href="#查看-2" class="headerlink" title="查看"></a>查看</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@variable</span>;</span><br></pre></td></tr></table></figure><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>在局部生效的变量，通过<code>DECLARE</code>声明，作用域处于变量所在的<code>BEGIN...END</code>块中。</p><h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> variable_name type [<span class="keyword">default</span> default_value];</span><br></pre></td></tr></table></figure><h5 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> variable_name :<span class="operator">=</span> <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">select</span> column_a <span class="keyword">into</span> variable_name <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if <span class="keyword">condition</span> <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- sql</span></span><br><span class="line">elseif <span class="keyword">condition</span> <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- sql</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">-- sql</span></span><br><span class="line"><span class="keyword">end</span> if;</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>类型：</p><ul><li>IN 输入参数</li><li>OUT 返回值</li><li>INOUT 既作为输入参数，也作为输出参数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_name(<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> pramameter_name type)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="keyword">when</span> <span class="keyword">condition</span> <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- sql</span></span><br><span class="line"><span class="keyword">when</span> <span class="keyword">condition</span> <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- sql</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">-- sql</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>类似C的while循环</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE <span class="keyword">condition</span> DO</span><br><span class="line"><span class="comment">-- sql</span></span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br></pre></td></tr></table></figure><h3 id="repeat-语句"><a href="#repeat-语句" class="headerlink" title="repeat 语句"></a>repeat 语句</h3><p>类似C的do while循环</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REPEAT</span><br><span class="line"><span class="comment">-- sql</span></span><br><span class="line">UNTIL <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br></pre></td></tr></table></figure><h3 id="loop语句"><a href="#loop语句" class="headerlink" title="loop语句"></a>loop语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[label:] LOOP</span><br><span class="line"><span class="comment">-- sql</span></span><br><span class="line">LEAVE label; <span class="comment">-- break</span></span><br><span class="line">ITERATE label; <span class="comment">-- continue</span></span><br><span class="line"><span class="keyword">END</span> LOOP [label];</span><br></pre></td></tr></table></figure><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>cursor，是用来存储查询结果集的数据类型。</p><h4 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement;</span><br></pre></td></tr></table></figure><blockquote><p>游标的声明必须在普通变量的声明之后</p></blockquote><h4 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> cursor_name</span><br></pre></td></tr></table></figure><h4 id="获取游标记录"><a href="#获取游标记录" class="headerlink" title="获取游标记录"></a>获取游标记录</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> variable_name, [...]; </span><br></pre></td></tr></table></figure><h4 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> cursor_name;</span><br></pre></td></tr></table></figure><h3 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> handler_action handler <span class="keyword">for</span> condition_value statement;</span><br></pre></td></tr></table></figure><ul><li>handler_action<ul><li>continue</li><li>exit</li></ul></li><li>condition_value<ul><li>sqlstate sqlstate_value</li><li>sqlwarning 01开头的SQLSTATE</li><li>not found 02开头的SQLSTATE</li><li>sqlexception</li></ul></li></ul><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> func_name ([arguments ...])</span><br><span class="line"><span class="keyword">returns</span> type [characteristic...]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">-- sql</span></span><br><span class="line"><span class="keyword">return</span> ...;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><ul><li>characteristic<ul><li>deterministic 系统的输入参数总是产生相同的结果</li><li>no sql 不包含SQL语句</li><li>reads sql data 包含读取数据的语句，但不包含写入数据的语句</li></ul></li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器能在<code>insert/update/delete</code>之前之后，触发并执行触发器中定义的SQL语句集合。触发器使用OLD和NEW来引用触发器中发生变化的记录内容。MySQL只支持行级触发器，不支持语句级触发器。</p><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">[BEFORE<span class="operator">|</span>AFTER] [<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>]</span><br><span class="line"><span class="keyword">ON</span> table_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- sql</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h3 id="查看-3"><a href="#查看-3" class="headerlink" title="查看"></a>查看</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [schema_name.]trigger_name;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之视图</title>
      <link href="/2024/08/27/MySQL%E4%B9%8B%E8%A7%86%E5%9B%BE/"/>
      <url>/2024/08/27/MySQL%E4%B9%8B%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>视图是一种虚拟表，它并不存储实际的数据，而是通过 SELECT 语句定义了一个结果集。视图可以简化复杂的查询，提供数据的安全访问机制，并且可以让用户看到多个表的组合结果。</p><ul><li>视图的定义本质上是一个 <code>SELECT</code> 语句。</li><li>当查询视图时，实际上是执行了视图定义中的 <code>SELECT</code> 语句。</li><li>视图还具有持久性、安全性、可重用性等特点，这使得它不仅仅是简单的 <code>SELECT</code> 语句别名。<ul><li>持久性：视图定义保存在数据库中，即使数据库重启后仍然存在；视图本身不存储数据，而是指向数据库中实际存储的数据</li><li>安全性：视图可以用来限制用户访问敏感数据；用户只能通过视图访问数据，而不能直接访问基础表</li><li>可重用性：视图可以被多次使用，就像使用表一样</li></ul></li></ul><h2 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句;</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询视图的<code>SELECT</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> view_name;</span><br></pre></td></tr></table></figure><p>查询视图数据用法和查询表数据用法一致</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul><li>方法一：<code>CREATE OR REPLACE VIEW view_name AS ...</code></li><li>方法二：<code>ALTER VIEW view_name AS ...</code></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> view_name;</span><br></pre></td></tr></table></figure><h2 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h2><p>视图的检查选项的作用是通过视图检查正在修改的每个行是否符合视图的定义。MySQL提供了两个选项：</p><ul><li>WITH CASCADED CHECK OPTION (默认值) 会递归检查操作是否满足当前视图以及其引用的所有视图的定义条件</li><li>WITH LOCAL CHECK OPTION 仅检查操作是否满足当前视图以及<strong>其引用且有检查选项的</strong>的视图的定义</li></ul><blockquote><ul><li>MySQL允许基于视图再创建视图</li><li>不建议通过视图进行增删改操作</li></ul></blockquote><h2 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h2><p>视图可更新必须满足视图的行和基础表的行必须存在一对一关系。若视图包含以下任意一项，该视图就不可更新：</p><ul><li>聚合函数&#x2F;窗口函数</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>UNION&#x2F; UNION ALL</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之SQL优化</title>
      <link href="/2024/08/25/MySQL%E4%B9%8BSQL%E4%BC%98%E5%8C%96/"/>
      <url>/2024/08/25/MySQL%E4%B9%8BSQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><ol><li><p>批量插入（但也不用一次插入超过1000条记录）</p><p><code>insert into ... values (...) (...) ... (...)</code></p></li><li><p>手动提交事务（可以避免频繁的事务开启和关闭）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> ...</span><br><span class="line"><span class="keyword">insert</span> ...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><p>主键顺序插入性能高于乱序插入</p></li><li><p>大批量插入数据使用MySQL提供的load指令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接服务端加上参数 --local-infile</span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line"></span><br><span class="line"># 设置全局参数local_infile=<span class="number">1</span></span><br><span class="line"><span class="built_in">set</span> global local_infile = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 执行load指令</span><br><span class="line">load data local infile &#x27;/<span class="built_in">path</span>/to/file&#x27; into table `table_name` fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure><h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>InnoDB的存储方式为<strong>索引组织表（IOT）</strong>,即表数据是根据主键顺序组织存放的。</p><h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>插入新数据时，若当前页没有足够的空间容纳新插入的数据，则会进行页分裂，即</p><ul><li>确认分割点</li><li>创建新页</li><li>重新分配记录</li><li>更新父节点</li></ul><blockquote><p>乱序插入可能导致频繁的页分裂，增加更多的磁盘I&#x2F;O开销</p></blockquote><h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>删除记录时，往往不会被物理删除，而是标记被删除记录空间，供其他记录声明使用；当页中删除的记录达到一定比例（<strong>MERGE_THRESHOLD</strong>），InnoDB会尝试合并相邻的页。</p><h3 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h3><ol><li>满足业务需求的情况下，尽量降低主键长度（长主键会导致更多的磁盘空间占用和增加更多磁盘I&#x2F;O开销）</li><li>插入时间尽量选择顺序插入，使用auto_increment自增主键</li><li>业务操作中，避免对主键的修改</li></ol><blockquote><p>尽量不要使用UUID或其他自然主键作为主键，如身份证，理由同1</p></blockquote><h2 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h2><p>InnoDB中排序的实现：</p><ol><li>Using filesort: 提供索引或全表扫描，读取相应的记录，在缓冲区进行排序</li><li>Using index: 通过有序索引顺序扫描直接返回结果</li></ol><p>给相应被排序字段创建索引即可实现优化（1-&gt;2）。</p><p>如果已经存在相关字段的（联合）索引，以下情况仍会导致using filesort:</p><ul><li>order by 字段顺序违背最左前缀法则</li><li>order by 不同字段的升降序性不同<ul><li>创建索引时默认字段按升序排列</li><li>创建索引时指定相应字段的升降序性可以实现优化</li></ul></li></ul><blockquote><ul><li>using index优化的前提是用到索引的覆盖索引</li><li>大数据量排序，不可避免filesort时，可以适当提高排序缓冲区大小</li></ul></blockquote><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><p>类似order by，也可以通过建立索引提高效率</p><h2 id="order-by-limit"><a href="#order-by-limit" class="headerlink" title="order by + limit"></a>order by + limit</h2><p>对于limit操作，数据量（偏离量）越大，检索效率越低</p><p>优化方案：覆盖索引+子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.<span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">Table</span> t1, (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">Table</span> <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">10000000</span>, <span class="number">10</span>) t2 <span class="keyword">where</span> t1.id<span class="operator">=</span>t2.id</span><br></pre></td></tr></table></figure><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><ul><li>MyISAM引擎把一张表总行数存在磁盘上，执行<code>count(*)</code>时就返回这个数，故效率很高</li><li>InnoDB则每次执行<code>count(*)</code>会全表遍历计数</li></ul><p>优化方案：维护自定义计数表</p><blockquote><p>count的四种用法：</p><ul><li>count(*) 统计表的总行数， 不取值</li><li>count(id&#x2F;主键) 取值判断，再按行累加</li><li>count(字段) 统计该字段不为NULL的记录总数， 取值判断</li><li>count(1) 按行累加1 (1可以替换成其他数字)， 不取值</li></ul><p>性能上：<strong>count(*) ≈ count(1) &gt; count(id) &gt; count(字段)</strong></p></blockquote><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>优化方案：尽量根据主键&#x2F;索引字段进行更新；避免使用非索引字段进行更新，导致表锁阻塞其他更新操作</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之索引</title>
      <link href="/2024/08/24/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/"/>
      <url>/2024/08/24/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><p>索引（Index）是MySQL<strong>高效</strong>获取数据的数据结构</p><p>优点：</p><ul><li>提高数据检索的效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><p>劣势：</p><ul><li>索引列要占空间</li><li>降低更新表的速度</li></ul><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>MySQL索引由存储引擎实现，不同存储引擎有不同结构：</p><ul><li>B+Tree 最常见</li><li>Hash</li><li>R-Tree</li><li>Full-text</li></ul><p><img src="/./pics/image-20240824145049683.png" alt="image-20240824145049683"></p><blockquote><p>数据结构补充：</p><p>搜索二叉树：任意节点都满足: 左子树最大值 &lt; 根节点值 &lt; 右子树最大值</p><p>红黑树： 平衡的搜索二叉树</p><p>B-Tree(多路平衡查找树): 一个节点最多可以存储4个key5个指针；每个指针指向的子树的值均在该指针相邻的key值表示的区间</p></blockquote><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><ul><li>所有元素会出现在叶子节点</li><li>根元素会出现在右节点第一个</li><li>MySQL中对经典B+Tree基础上，在叶子节点增加了指向相邻叶子节点的指针</li></ul><blockquote><ul><li>相对二叉树，层级更少，搜索效率高</li><li>相对于B-Tree，要保存叶子节点和非叶子节点，导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li></ul></blockquote><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>用hash算法将键值换算城信hash值，映射在对应槽位上，再存储在hash表中</p><ul><li>只能用于对等比较，不支持范围查询</li><li>无法利用索引完成排序操作</li><li>查询效率高</li></ul><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p><img src="/./pics/image-20240824152438057.png" alt="image-20240824152438057"></p><p>InnoDB中，索引又可以分为<strong>聚集索引</strong>和<strong>二级索引</strong></p><p><img src="/./pics/image-20240824152630129.png" alt="image-20240824152630129"></p><p>聚集索引选取规则：</p><ul><li>存在主键，主键索引就是聚集索引</li><li>不存在主键，将使用第一个唯一索引作为聚集索引</li><li>都没有，InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul><blockquote><p>回表查询：先从二级索引中拿到行id，再用id从聚集索引找到该行的记录</p></blockquote><h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT] INDEX index_name <span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure><blockquote><p>一个索引只关联一个字段：单列索引</p><p>一个索引只关联多个字段：联合索引&#x2F;组合索引</p></blockquote><h3 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h3><p>查询现有索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index index_name <span class="keyword">on</span> table_name;</span><br></pre></td></tr></table></figure><h2 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h2><h3 id="SQL执行频率"><a href="#SQL执行频率" class="headerlink" title="SQL执行频率"></a>SQL执行频率</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> &#123;<span class="keyword">global</span><span class="operator">|</span>session&#125; status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志会保存执行时间超过某一阈值的SQL语句。</p><p>查看慢日志开启状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure><p>开启慢查询日志:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># /etc/my.cnf</span><br><span class="line"></span><br><span class="line">slow_query_log=<span class="number">1</span></span><br><span class="line"># 超时阈值（秒）</span><br><span class="line">long_query_time=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>慢查询日志位置：<code>/var/lib/mysql/localhost-slow.log</code></p><h3 id="Profile详情"><a href="#Profile详情" class="headerlink" title="Profile详情"></a>Profile详情</h3><p>profiles能在做SQL优化是帮助我们了解时间耗费的分布情况。</p><p>查询是否支持profiles</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> @<span class="variable">@have</span>_profiling;</span><br></pre></td></tr></table></figure><p>查询是否开启profiles</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> @<span class="variable">@profiling</span>;</span><br></pre></td></tr></table></figure><p>开启profiles</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查询当前会话SQL的耗时情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定query_id的SQL语句耗时情况</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ...的CPU使用情况</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id</span><br></pre></td></tr></table></figure><h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h3><p>用<code>explain/desc</code>命令获取MySQL如何执行SELECT语句的信息</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;explain<span class="operator">|</span><span class="keyword">desc</span>&#125; <span class="keyword">SQL</span>查询语句</span><br></pre></td></tr></table></figure><p>各字段含义：</p><ul><li>id<ul><li>表示查询中执行select子句的顺序（越大先执行，相同则从上到下执行）</li></ul></li><li>select_type<ul><li>SIMPLE</li><li>PRIMARY 外层查询</li><li>UNION</li><li>SUBQUERY 子查询</li></ul></li><li>type (由好到坏)<ul><li>NULL 不访问任何表的查询</li><li>system 访问系统表</li><li>const 查询常量表或表只有一行数据</li><li>eq_ref 使用唯一索引</li><li>ref 使用非唯一索引</li><li>range 使用索引的一部分查询</li><li>index 全索引查询</li><li>all 全表查询</li></ul></li><li>possible_key<ul><li>可能应用这张表的索引</li></ul></li><li>Key<ul><li>实际用到的索引</li></ul></li><li>Key_len<ul><li>表示索引中引用的字节数</li></ul></li><li>rows<ul><li>MySQL认为必须要执行查询的行数</li></ul></li><li>filtered<ul><li>返回结果的函数占需读取的行数的百分比</li></ul></li></ul><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><ul><li>最左前缀法则（<strong>联合索引</strong>）<ul><li>从索引的最左列开始，并且不跳过索引中的列（如果跳跃某一列，后面的索引会失效）</li></ul></li><li>范围查询<ul><li>联合索引中，出现范围查询（<code>&lt;</code>, <code>&gt;</code>）会使右侧的列索引失效</li><li>可以使用<code>&gt;=</code>或<code>&lt;=</code>解决</li></ul></li><li>索引列运算<ul><li>在索引列上进行运算操作，索引将失效</li></ul></li><li>字符串不加引号<ul><li>字符串不加引号（导致隐式转换）也会导致索引失效</li></ul></li><li>模糊查询<ul><li>头部模糊匹配会导致索引失效</li></ul></li><li>or连接的条件<ul><li>如果or之前有用到索引，后面没有用到索引，会导致索引失败</li><li>给原本没有索引的字段创建索引就解决。</li></ul></li><li>数据分布影响<ul><li>如果使用索引比全表搜索还慢，则不会使用索引</li></ul></li><li>SQL提示<ul><li>use index(index_name) 建议</li><li>ignore index(index_name) 忽略</li><li>force index(index_name) 强制 </li><li>在from子句之后使用</li></ul></li><li>覆盖索引<ul><li>指查询使用索引，且返回的列在该索引中都能找到</li><li>不推荐用<code>select *</code></li></ul></li></ul><blockquote><p>extra信息：</p><ul><li>using index condition: 查找使用了索引，但是需要回表查询</li><li>using where, using index: 直接从索引返回结果</li></ul></blockquote><ul><li>前缀索引<ul><li>可以用字符串的一部分前缀建立索引，可以大大节约索引空间，提高索引效率</li><li><code>create index index_name on table_name(column(n))</code>, 前缀长度为n</li></ul></li><li>单列索引与联合索引<ul><li>业务场景中，如果涉及多个字段的查询，则建议使用联合索引</li><li>可以通过SQL提示来指定查询时使用联合索引</li></ul></li></ul><h2 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h2><ol><li>数据量较大（&gt;&#x3D; 一百万条），查询频繁</li><li>针对常作为where, order by, group by操作的字段建立索引</li><li>尽量选择区分度高的列作为索引</li><li>对于长字符串字段建立索引，建议使用前缀索引</li><li>尽量使用联合索引，可以覆盖索引</li><li>控制索引数量，索引越多，维护索引的代价也越大，影响增删改的效率</li><li>建表时使用NOT NULL可以让优化器更好的确定哪个索引最有效地用于查询</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之存储引擎</title>
      <link href="/2024/08/24/MySQL%E4%B9%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2024/08/24/MySQL%E4%B9%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><ul><li>连接层<ul><li>处理客户端连接；认证与授权</li></ul></li><li>服务层<ul><li>SQL接口</li><li>解析器</li><li>查询优化器</li><li>缓存</li></ul></li><li>引擎层<ul><li>可插拔的存储引擎</li></ul></li><li>存储层<ul><li>Redo</li><li>Undo</li><li>Data</li><li>Index</li><li>Binary</li><li>Error等</li></ul></li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎是存储数据，建立索引，更新&#x2F;查询数据等技术的实现方式。</p><p>存储引擎基于表，而不是库，所以存储引擎也被称为表类型的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 展示当前数据库支持的存储引擎</span></span><br><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><p>在建表语句末尾可加上<code>engine=xxx</code>来使用指定的存储引擎</p><h2 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li>DML遵循ACID，支持<strong>事务</strong></li><li><strong>行级锁</strong></li><li>支持<strong>外键</strong></li><li>每个表对应一个xxx.ibd文件，用<code>innodb_file_per_table</code>控制，默认为<code>ON</code></li></ul><p>可以用<code>ibd2sdi</code>工具来从ibd文件提取出sdi表结构数据</p><p>逻辑存储结构</p><ul><li>TableSpace</li><li>Segment</li><li>Extent</li><li>Page</li><li>Row</li></ul><p><img src="/./pics/image-20240824141841982.png" alt="image-20240824141841982"></p><blockquote><p>应用场景：要求事务完整性，并发条件下要求数据的一致性，数据操作包括增删改查</p></blockquote><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>sdi 存储表结构消息</li><li>MYD 存储数据</li><li>MYI 存储索引</li></ul><blockquote><p>应用场景：以读操作和插入操作为主，对事务完整性，并发性要求不高；但目前该场景下一般用NoSQL数据库如MongoDB</p></blockquote><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>该引擎将数据存在内存中。</p><ul><li>内存存放</li><li>hash索引</li></ul><p>文件：</p><ul><li>sdi</li></ul><p><img src="/./pics/image-20240824142421073.png" alt="image-20240824142421073"></p><blockquote><p>应用场景：用于临时表及缓存</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2024/08/20/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/08/20/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><p>redis是一个键值存储系统，其数据存储在内存中，故常作为后端应用的缓存数据库来提高存储层的数据吞吐量。</p><p>特点：</p><ul><li>键值型存储</li><li>单线程（指命令执行）</li><li>低延迟，速度快</li></ul><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><p>通用命令查询指令：<code>help @generic</code></p><p>常见redis通用命令：</p><ul><li>keys 查询键值（支持模糊查询，生产环境不适用）</li><li>del 删除键值，返回成功删除的键值对数</li><li>exists 判断key是否存在</li><li>expire 给一个key设置有效期</li><li>ttl 查看一个key的剩余有效期</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>redis中最简单的存储类型。根据字符串格式可分为3类：</p><ul><li>string 普通字符串</li><li>int 整型</li><li>float 浮点型</li></ul><p>int和float可以做增减操作；字符串类型最大空间不能超过512MB</p><p>常用命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name john</span><br><span class="line"></span><br><span class="line">get name # john</span><br><span class="line"></span><br><span class="line">mset k1 v1 k2 v2 k3 <span class="number">1</span> k4 <span class="number">0</span>.<span class="number">5</span></span><br><span class="line"></span><br><span class="line">mget name k1 k2 </span><br><span class="line">#<span class="number">1</span>) john</span><br><span class="line">#<span class="number">2</span>) v1</span><br><span class="line">#<span class="number">3</span>) v2</span><br><span class="line"></span><br><span class="line">incr k3 # <span class="number">2</span></span><br><span class="line"></span><br><span class="line">incrby k3 <span class="number">2</span> # <span class="number">4</span></span><br><span class="line"></span><br><span class="line">decrby k3 <span class="number">2</span> # <span class="number">2</span></span><br><span class="line"></span><br><span class="line">decr k3 # <span class="number">1</span></span><br><span class="line"></span><br><span class="line">incrbyfloat k4 <span class="number">0</span>.<span class="number">6</span></span><br><span class="line"></span><br><span class="line">setnx k1 v4 # <span class="number">0</span></span><br><span class="line">get k1 # v1</span><br><span class="line"></span><br><span class="line">setex k5 <span class="number">10</span> <span class="number">1</span> # expire为<span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>推荐的key命名方式：项目名:业务名:类型:id；可实现key的分级存储</p></blockquote><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>hash类型允许在redis中存储键值对，每个哈希都有一个唯一的键，并且包含多个字段（field）到值（value）的映射对，类似golang中的map，python的dict。</p><p>常见命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># hset key field value</span><br><span class="line">hset web:user:<span class="number">1</span> name john</span><br><span class="line">hset web:user:<span class="number">1</span> email <span class="number">123</span>@qq.com</span><br><span class="line"></span><br><span class="line">hget web:user:<span class="number">1</span> name # john</span><br><span class="line">hget web:user:<span class="number">1</span> email # <span class="number">123</span>@qq.com</span><br><span class="line"></span><br><span class="line"># 还有类似mset mget的 hmset hmget</span><br><span class="line"></span><br><span class="line">hgetall web:user:<span class="number">1</span></span><br><span class="line">#<span class="number">1</span>) &quot;name&quot;</span><br><span class="line">#<span class="number">2</span>) &quot;john&quot;</span><br><span class="line">#<span class="number">3</span>) &quot;email&quot;</span><br><span class="line">#<span class="number">4</span>) &quot;<span class="number">123</span>@qq.com&quot;</span><br><span class="line"></span><br><span class="line">hkeys web:user:<span class="number">1</span></span><br><span class="line">#<span class="number">1</span>) &quot;name&quot;</span><br><span class="line">#<span class="number">2</span>) &quot;email&quot;</span><br><span class="line"></span><br><span class="line">hvals web:user:<span class="number">1</span></span><br><span class="line">#<span class="number">1</span>) &quot;john&quot;</span><br><span class="line">#<span class="number">2</span>) &quot;<span class="number">123</span>@qq.com&quot;</span><br><span class="line"></span><br><span class="line"># 还有类似的hincrby hsetnx等命令</span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>list通常被用来模拟队列（FIFO，先进先出）或栈（LIFO，后进先出）的行为。列表支持的操作使得它可以非常方便地用作消息队列、任务队列等场景。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lpush list a</span><br><span class="line">lpush list b</span><br><span class="line">rpush list c</span><br><span class="line"></span><br><span class="line">lrange list <span class="number">0</span> <span class="number">2</span></span><br><span class="line">#<span class="number">1</span>) &quot;b&quot;</span><br><span class="line">#<span class="number">2</span>) &quot;a&quot;</span><br><span class="line">#<span class="number">3</span>) &quot;c&quot;</span><br><span class="line"></span><br><span class="line">lpop list # b</span><br><span class="line">rpop list # c</span><br><span class="line">rpop list # a</span><br><span class="line">lpop list # nil</span><br><span class="line"></span><br><span class="line"># blpop brpop 类似lpop rpop,但会在没元素时等待指定时间，不会直接返回nil</span><br><span class="line">blpop list <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>集合，类似python的set。特点如下：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集</li></ul><p>常用命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sadd s1 <span class="number">1</span></span><br><span class="line">sadd s1 <span class="number">2</span></span><br><span class="line">sadd s2 <span class="number">2</span></span><br><span class="line">sadd s2 <span class="number">3</span></span><br><span class="line"></span><br><span class="line">srem s1 <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scard s2 # <span class="number">2</span></span><br><span class="line">sismember s2 <span class="number">2</span> # yes</span><br><span class="line">smembers s2</span><br><span class="line">#<span class="number">1</span>) <span class="number">2</span></span><br><span class="line">#<span class="number">2</span>) <span class="number">3</span></span><br><span class="line"></span><br><span class="line">sinter s1 s2</span><br><span class="line"># <span class="number">2</span></span><br><span class="line"></span><br><span class="line">sdiff s2 s1</span><br><span class="line"># <span class="number">3</span></span><br><span class="line"></span><br><span class="line">sunion s1 s2</span><br><span class="line">#<span class="number">1</span>) <span class="number">2</span></span><br><span class="line">#<span class="number">2</span>) <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><p>可排序的set，底层每个元素都拥有一个score属性，可以基于score属性对元素进行排序</p><p>常见命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zadd z1 <span class="number">10</span> john</span><br><span class="line">zrem z1 john</span><br><span class="line"></span><br><span class="line">zadd z1 <span class="number">5</span> john</span><br><span class="line">zadd z1 <span class="number">6</span> blob</span><br><span class="line">zscore z1 john # <span class="number">5</span></span><br><span class="line">zrank z1 john # <span class="number">0</span></span><br><span class="line">zcard z1 # <span class="number">2</span></span><br><span class="line">zcount z1 <span class="number">3</span> <span class="number">6</span> # <span class="number">2</span></span><br><span class="line">zincrby z1 <span class="number">2</span> john # <span class="number">7</span></span><br><span class="line">zrange z1 <span class="number">0</span> <span class="number">1</span></span><br><span class="line">#<span class="number">1</span>) blob</span><br><span class="line">#<span class="number">2</span>) john</span><br><span class="line">zrangebyscore z1 <span class="number">5</span> <span class="number">6</span></span><br><span class="line">#<span class="number">1</span>) blob</span><br><span class="line">zdiff/zinter/zunion</span><br></pre></td></tr></table></figure><h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><p>BitMap时用于存储和操作位级别的数据，它通常用于表示大量布尔值的状态。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setbit status <span class="number">0</span> <span class="number">1</span></span><br><span class="line">setbit status <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">getbit status <span class="number">0</span> # <span class="number">1</span></span><br><span class="line">getbit status <span class="number">1</span> # <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 本质上bitmap就是字符串</span><br><span class="line"><span class="built_in">set</span> status &quot;\x0F&quot;</span><br><span class="line"></span><br><span class="line">getbit status <span class="number">3</span> # <span class="number">0</span></span><br><span class="line">getbit status <span class="number">4</span> # <span class="number">1</span></span><br><span class="line"></span><br><span class="line">bitcount status # <span class="number">4</span></span><br><span class="line"></span><br><span class="line">bitpos status <span class="number">0</span> # <span class="number">0</span></span><br><span class="line">bitpos status <span class="number">1</span> # <span class="number">4</span></span><br><span class="line">bitpos status <span class="number">0</span> <span class="number">3</span> <span class="number">4</span> bit # <span class="number">3</span></span><br><span class="line">bitpos status <span class="number">0</span> <span class="number">3</span> <span class="number">4</span> [byte]# -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>HyperLogLog (HLL) 是一种用于估计大量数据中不同元素（即基数）数量的数据结构。它牺牲了一定的精确性，换来了更小的内存消耗。</p><p>常用命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pfadd product1 fruit vegetable</span><br><span class="line">pfcount product1</span><br><span class="line"></span><br><span class="line">pfadd product2 meat milk</span><br><span class="line"></span><br><span class="line">pfmerge result product1 product2</span><br><span class="line"></span><br><span class="line">pfcount result</span><br><span class="line"># <span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务</title>
      <link href="/2024/08/20/MySQL%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/08/20/MySQL%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，是不可分割的工作单位。事务中的所有操作要么同时成功，要么同时失败。事务保证了MySQL的ACID特性。</p><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">start</span> transation;</span><br><span class="line">...</span><br><span class="line"><span class="comment">-- 提交|回滚</span></span><br><span class="line"><span class="keyword">commit</span><span class="operator">|</span><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方法二</span></span><br><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">commit</span><span class="operator">|</span><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><ul><li>Atomicity 原子性， 事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>Consistency 一致性， 事务完成，必须使所有数据保持一致性</li><li>Isolation 隔离性， 数据库系统提供隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>Durablitiy 持久性， 事务一旦提交或回滚，对数据的改变是永久的</li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>并发事务一般会有以下问题：</p><ul><li>脏读：一个事务读到另一个事务还没提交的数据</li><li>不可重复读：一个事务先后读取同一记录，但两次读取的数据不同</li><li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但在插入数据时，又发现该数据已经存在</li></ul><p>MySQL隔离级别：</p><ul><li>Read uncommitted</li><li>Read committed 解决了脏读</li><li>Repeatable Read (default) 解决了脏读和不可重复读</li><li>Serializable 解决了脏读+不可重复+幻读</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询事务隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@TRANSACTION</span>_ISOLATION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置隔离级别</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level [level];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL常用函数</title>
      <link href="/2024/08/19/MySQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2024/08/19/MySQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul><li>concat(s1, s2, …, sn) 拼接多个字符串</li><li>upper(s) 将字符串中所有字符转化为大写字母</li><li>lower(s) 将字符串中所有字符转化为小写字母</li><li>lpad(str, n, pad) 用pad左填充字符串str至长度为n的字符串</li><li>rpad(str, n, pad) 类似lpad，但右填充</li><li>trim(str) 去掉字符串头尾的空格</li><li>length(str) 获取字符串长度</li><li>substring(str, start, len) 返回字符串str从start起len长度的字符串(MySQL中字符串下标从1开始计算)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>); <span class="comment">-- Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">upper</span>(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">-- HELLO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">lower</span>(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">-- hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> lpad(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>); <span class="comment">-- 0Hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> rpad(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>); <span class="comment">-- Hello0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27; Hello  &#x27;</span>); <span class="comment">-- Hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;MySQL&#x27;</span>, <span class="number">3</span>, length(<span class="string">&#x27;MySQL&#x27;</span>) <span class="operator">-</span> <span class="number">2</span>); <span class="comment">-- SQL</span></span><br></pre></td></tr></table></figure><h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><ul><li>ceil(x) 向上取整</li><li>floor(x) 向下取整</li><li>mod(x, y) 求 x % y</li><li>rand() 返回一个0到1的浮点数</li><li>round(x, y) 对x进行四舍五进，保留y位小数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">ceil</span>(<span class="number">1.1</span>); <span class="comment">-- 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">floor</span>(<span class="number">1.1</span>); <span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">mod</span>(<span class="number">9</span>, <span class="number">4</span>); <span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> round(<span class="number">1</span> <span class="operator">/</span> <span class="number">3</span>, <span class="number">3</span>); <span class="comment">-- 0.333</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成6位随机数字</span></span><br><span class="line"><span class="keyword">select</span> lpad(<span class="built_in">floor</span>(rand() <span class="operator">*</span> <span class="number">1000000</span>), <span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><ul><li>curdate() 返回当前日期（年月日）</li><li>curtime()         返回当前时间（时分秒）</li><li>now()              返回当前日期+时间（YY-MM-DD HH:MM:SS)</li><li>year(date)       解析日期字符串并返回年份</li><li>month(date)   解析日期字符串并返回月份</li><li>day(date)        解析日期字符串并返回天数</li><li>date_add(date, interval expr type) 计算date加上一个日期偏移量的结果</li><li>datediff(date1, date2)  返回date1到date2的日数差</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> now(); <span class="comment">-- 2024-08-19 15:40:00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> curdate(); <span class="comment">-- 2024-08-19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> curtime(); <span class="comment">-- 15:40:00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">year</span>(<span class="string">&#x27;2024-08-19 15:40:00&#x27;</span>); <span class="comment">-- 2024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">month</span>(<span class="string">&#x27;2024-08-19 15:40:00&#x27;</span>); <span class="comment">-- 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">day</span>(<span class="string">&#x27;2024-08-19 15:40:00&#x27;</span>); <span class="comment">-- 19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> date_add(<span class="string">&#x27;2024-08-19 15:40:00&#x27;</span>, <span class="type">interval</span> <span class="number">1</span> <span class="keyword">day</span>); <span class="comment">-- 2024-08-20 15:40:00 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> datediff(<span class="string">&#x27;2024-08-20 15:40:00&#x27;</span>, <span class="string">&#x27;2024-08-19 15:40:00&#x27;</span>); <span class="comment">-- 1</span></span><br></pre></td></tr></table></figure><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><ul><li>if(value, t, f), 若value为真，则返回t，否则返回f</li><li>ifnull(value1, value2) , 若value1不为空，则返回value1，否则返回value2</li><li>case when [val1] then [res] … end 条件分支语句</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> if(<span class="literal">true</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>); <span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ifnull(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;2&#x27;</span>); <span class="comment">-- &#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ifnull(<span class="keyword">null</span>, <span class="string">&#x27;2&#x27;</span>); <span class="comment">-- 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- http://sqlmother.yupi.icu/#/learn/level13</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  name,</span><br><span class="line">  <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> (age <span class="operator">&gt;</span> <span class="number">60</span>) <span class="keyword">THEN</span> <span class="string">&#x27;老同学&#x27;</span></span><br><span class="line">    <span class="keyword">WHEN</span> (age <span class="operator">&gt;</span> <span class="number">20</span>) <span class="keyword">THEN</span> <span class="string">&#x27;年轻&#x27;</span></span><br><span class="line">    <span class="keyword">ELSE</span> <span class="string">&#x27;小同学&#x27;</span></span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> age_level</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  student</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  name <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础(基于MySQL)</title>
      <link href="/2024/08/19/SQL%E5%9F%BA%E7%A1%80(%E5%9F%BA%E4%BA%8EMySQL)/"/>
      <url>/2024/08/19/SQL%E5%9F%BA%E7%A1%80(%E5%9F%BA%E4%BA%8EMySQL)/</url>
      
        <content type="html"><![CDATA[<h2 id="DDL-Data-Definition-Language"><a href="#DDL-Data-Definition-Language" class="headerlink" title="DDL(Data Definition Language)"></a>DDL(Data Definition Language)</h2><h3 id="表查询"><a href="#表查询" class="headerlink" title="表查询"></a>表查询</h3><ul><li>查询当前所有表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><ul><li>查询表结构</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> TABLE_NAME;</span><br></pre></td></tr></table></figure><ul><li>查询指定表建表语句</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLE_NAME;</span><br></pre></td></tr></table></figure><h3 id="表创建"><a href="#表创建" class="headerlink" title="表创建"></a>表创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLE_NAME (</span><br><span class="line">COLUMN_NAME TYPE [COMMENT] [<span class="keyword">CONDITION</span>],</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>数值类型<ul><li>TINYINT 1byte</li><li>SMALLINT      2bytes</li><li>MEDIUMINT  3bytes</li><li>INT &#x2F; INTEGER 4bytes</li><li>SIGINT            8bytes</li><li>FLOAT             4bytes  float(m, d) 类似decimal</li><li>DOUBLE          8bytes  double(m,d) 类似decimal</li><li>DECIMAL        decimal(a,b) a表示小数点左边能存储的十进制数字最大数，b表示小数点右边…</li></ul></li></ul><blockquote><p>对于数值类型，可以在字段约束条件中使用unsigned来声明无符号类型。</p></blockquote><ul><li>字符串类型<ul><li>CHAR CHAR(N) 定长为n的字符串</li><li>VARCHAR VARCHAR(N) 最长为n的字符串</li><li>TINYTEXT, BLOB, TEXT, … 等长文本或二进制数据</li></ul></li><li>日期类型<ul><li>DATE</li><li>TIME</li><li>YEAR</li><li>DATETIME 日期+时间</li><li>TIMESTAMP 时间戳</li></ul></li></ul><h3 id="表修改"><a href="#表修改" class="headerlink" title="表修改"></a>表修改</h3><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLE_NAME RENAME <span class="keyword">AS</span> NEW_TABLE_NAME;</span><br><span class="line"><span class="comment">-- 方法二</span></span><br><span class="line">RENAME <span class="keyword">TABLE</span> OLD_TABLE_NAME <span class="keyword">TO</span> NEW_TABLE_NAME</span><br></pre></td></tr></table></figure><h4 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLE_NAME <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> TYPE [COMMENT] [<span class="keyword">CONDITION</span>];</span><br></pre></td></tr></table></figure><h4 id="修改字段类型"><a href="#修改字段类型" class="headerlink" title="修改字段类型"></a>修改字段类型</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLE_NAME MODIFY <span class="keyword">COLUMN</span> NEWTYPE;</span><br></pre></td></tr></table></figure><h4 id="修改字段名"><a href="#修改字段名" class="headerlink" title="修改字段名"></a>修改字段名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLE_NAME RENAME OLD_COLUMN <span class="keyword">TO</span> NEW_COLUMN;</span><br></pre></td></tr></table></figure><h4 id="修改字段名和类型"><a href="#修改字段名和类型" class="headerlink" title="修改字段名和类型"></a>修改字段名和类型</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLE_NAME CHANGE OLD_COLUMN NEW_COLUMN NEWTYPE [COMMENT] [<span class="keyword">CONDITION</span>];</span><br></pre></td></tr></table></figure><h4 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLE_NAME <span class="keyword">DROP</span> <span class="keyword">COLUMN</span>;</span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] TABLE_NAME;</span><br></pre></td></tr></table></figure><h4 id="删除并重新创建表"><a href="#删除并重新创建表" class="headerlink" title="删除并重新创建表"></a>删除并重新创建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> TABLE_NAME;</span><br></pre></td></tr></table></figure><h2 id="DML-Data-Manipulation-Language"><a href="#DML-Data-Manipulation-Language" class="headerlink" title="DML (Data Manipulation Language)"></a>DML (Data Manipulation Language)</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLE_NAME [(COLUMN1, COLUMN2, ...)] <span class="keyword">VALUES</span> (VALUE1, VALUE2,...), (VALUE1, VALUE2,...), ...;</span><br></pre></td></tr></table></figure><blockquote><p>添加数据时忽略未给出字段，则表明给全部字段添加数据</p></blockquote><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> TABLE_NAME <span class="keyword">SET</span> COLUMN1<span class="operator">=</span>VALUE1, COLUMN2<span class="operator">=</span>VALUE2,...</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">CONDITION</span>];</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span> [<span class="keyword">WHERE</span> <span class="keyword">CONDITION</span>];</span><br></pre></td></tr></table></figure><h2 id="DQL-Data-Query-Language"><a href="#DQL-Data-Query-Language" class="headerlink" title="DQL(Data Query Language)"></a>DQL(Data Query Language)</h2><p>关键知识点：</p><ul><li>选择查询</li><li>别名</li><li>where条件</li><li>order by排序</li><li>group by分组</li><li>limit 截断和偏移</li><li>case when then … end条件分支</li><li>having条件（针对group by 分组）</li><li>内连接、外连接</li><li>聚合函数</li><li>开窗函数</li><li>子查询, exist, in</li><li>with as语句</li></ul><h2 id="DCL-Data-Control-Language"><a href="#DCL-Data-Control-Language" class="headerlink" title="DCL(Data Control Language)"></a>DCL(Data Control Language)</h2><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>可以使用通配符%来表示任意主机。</p></blockquote><h3 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;newpassword&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="查询权限"><a href="#查询权限" class="headerlink" title="查询权限"></a>查询权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span><span class="operator">|</span>OTHER PRIVILEGE <span class="keyword">ON</span> DATABASE.TABLE <span class="keyword">TO</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="撤销权限"><a href="#撤销权限" class="headerlink" title="撤销权限"></a>撤销权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span><span class="operator">|</span>OTHER PRIVILEGE <span class="keyword">ON</span> DATABASE.TABLE <span class="keyword">FROM</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang并发</title>
      <link href="/2024/07/29/Golang%20%E5%B9%B6%E5%8F%91/"/>
      <url>/2024/07/29/Golang%20%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>并行与并发的区别：</p><ul><li>并发是指一个处理器同时处理多个任务。</li><li>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。</li></ul></blockquote><p>Go 的并发模型基于 <strong>协程</strong> 和 <strong>通道</strong>（channels）。</p><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>Goroutine就是Go并发中的协程，是一种更轻量的用户级线程，由Go在运行时管理。特点如下：</p><ul><li>轻量：系统线程栈空间通常$\ge$1MB，Goroutine 的栈空间初始大小只有 2KB，可以动态扩容</li><li>高效：Goroutine 的调度器采用 M:N 模型，可以将 M 个 Goroutine 映射到 N 个 OS 线程上，实现高效调度</li><li>高并发：可创建数十万协程</li><li>方便：在Golang中，只要在函数调用前加上关键字<code>go</code>就可以启动异步Goroutine</li></ul><p>这里给出一个简单的Goroutine例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d started\n&quot;</span>, id)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d finished\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">go</span> worker(i) <span class="comment">// 启动worker协程</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 阻塞主线程，等待所有worker完成</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Done.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Worker 1 started</span></span><br><span class="line"><span class="comment">Worker 0 started</span></span><br><span class="line"><span class="comment">Worker 4 started</span></span><br><span class="line"><span class="comment">Worker 3 started</span></span><br><span class="line"><span class="comment">Worker 2 started</span></span><br><span class="line"><span class="comment">Worker 2 finished</span></span><br><span class="line"><span class="comment">Worker 4 finished</span></span><br><span class="line"><span class="comment">Worker 3 finished</span></span><br><span class="line"><span class="comment">Worker 0 finished</span></span><br><span class="line"><span class="comment">Worker 1 finished</span></span><br><span class="line"><span class="comment">Done.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这里补充一个<strong>Go1.22</strong>之前的版本存在的一个问题。在<strong>Go1.22</strong>之前，对于 <code>for</code> 循环中的范围表达式（<code>for range</code>），循环变量的初始化是在循环开始时仅执行一次的。这意味着每次循环迭代时，都会使用同一个变量，而不是为每次迭代创建一个新的变量副本。</p><p>通常情况下不会出现问题，除了<code>for range</code>循环变量和Goroutine结合使用时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    alpha := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> alpha &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s&quot;</span>, v)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直观上觉得程序会输出<code>&quot;ab&quot;</code>，但实际上往往会输出<code>&quot;bb&quot;</code>。这是因为goroutine是异步的，当第一个循环结束时，程序可能还未打印出<code>v</code>，结果进入第二个循环后，<code>v</code>被修改为了<code>&quot;b&quot;</code>，两个goroutine就都打印了最后的<code>v</code>，即结果为<code>&quot;bb&quot;</code></p><p>解决办法：</p><ol><li>函数传参</li><li>创建新局部变量</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    alpha := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 方法1</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> alpha &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s&quot;</span>, x)</span><br><span class="line">        &#125;(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法2</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> alpha &#123;</span><br><span class="line">        newV := v</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;%s&quot;</span>, newV)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go1.22中，<code>for range</code>循环变量改成为每次迭代创建一个新的变量副本，故不存在上述问题了。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><code>channel</code>是Go中的一种复杂数据类型，可看作特殊的队列，具有先进先出的特点，用于同步协程间通信。一般用于协程间的数据通信。</p><h3 id="声明格式"><a href="#声明格式" class="headerlink" title="声明格式"></a>声明格式</h3><p>一般的通道声明格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var ch chan [type]</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="comment">// 当然你还可以指定缓冲区大小</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>一个通道只能传输一种类型的数据；所有的类型的数据都可以用于通道，包括空接口。</p><p>使用<code>make()</code>对通道进行声明时，如果不指定缓冲区大小，则返回<strong>无缓冲通道</strong>，否则返回<strong>带缓冲通道</strong>。</p><p>通道中还有<strong>只读通道</strong>和<strong>只写通道</strong>。当然，声明一个只读或只写的通道没有意义，所以这两种通道一般用于构建函数参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reader</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;&#125; <span class="comment">// 只读通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Writer</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;&#125; <span class="comment">// 只写通道</span></span><br></pre></td></tr></table></figure><p>这样就可以保证<code>Reader</code>中ch通道是只读的，<code>Writer</code>中<code>ch</code>通道是只写的。下文会给出更详细的例子。</p><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向通道写入10</span></span><br><span class="line">ch &lt;- <span class="number">10</span> </span><br></pre></td></tr></table></figure><p>值得注意的是，当向一个无缓冲通道（或者有缓冲但会写入数据量超过缓冲区的通道）写入数据时，必须保证有一个读协程随时准备从通道数据，否则会出现死锁报错：<code>fatal error: all goroutines are asleep - deadlock!</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">5</span> <span class="comment">// Dead lock!</span></span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(&lt;-ch)</span><br><span class="line">    &#125;()</span><br><span class="line">    ch &lt;- <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读操作的第二个返回值如果是false，则管道关闭且为空</span></span><br><span class="line">ret, ok := &lt;-ch</span><br><span class="line"><span class="comment">// 当然你也可以省略ok</span></span><br><span class="line">ret := &lt;-ch</span><br></pre></td></tr></table></figure><p>注意的是，当尝试向空通道进行读操作时，会引发<strong>通道阻塞</strong>，直到通道中有新值写入，这样新值就会被读出，并结束阻塞。</p><h3 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h3><p>通道是可以关闭的。一旦关闭，就无法向该channel写入数据。<strong>注意的是</strong>，空通道关闭后，仍可以多次从通道读出零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// 0</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// 0</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Channel closed&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="遍历channel"><a href="#遍历channel" class="headerlink" title="遍历channel"></a>遍历channel</h3><p>想要遍历<code>channel</code>前，必须先关闭<code>channel</code>。关闭<code>channel</code>后就不能向<code>channel</code>写入数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭通道</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad!</span></span><br><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// panic: send on closed channel</span></span><br></pre></td></tr></table></figure><p>遍历方法一般有两种，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案A，能自动检测管道是否关闭</span></span><br><span class="line"><span class="keyword">for</span> val := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    fmt.Println(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案B</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    val, ok := &lt;- ch</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125; </span><br><span class="line">    fmt.Println(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad!</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ch); i++ &#123;</span><br><span class="line">    <span class="comment">// len(ch)会变化！</span></span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Select语句"><a href="#Select语句" class="headerlink" title="Select语句"></a>Select语句</h3><p>Go中的<code>select</code>语句是专门处理通道操作的语句，一般与<code>for</code>语句配合使用，也被频繁用在Go的并发编程中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        <span class="comment">// 当 ch1 准备好接收时执行这里的代码</span></span><br><span class="line">    <span class="keyword">case</span> ch2 &lt;- <span class="string">&quot;value&quot;</span>:</span><br><span class="line">        <span class="comment">// 当 ch2 准备好发送时执行这里的代码</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 如果没有通道准备就绪，则执行这里的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select语句特点如下：</p><ol><li><strong>非阻塞</strong>:<ul><li>如果没有任何 case 的通道准备就绪，<code>select</code> 语句将选择执行 <code>default</code> 子句（如果有的话）。</li><li>如果没有 <code>default</code> 子句并且所有 case 的通道都不准备就绪，则 <code>select</code> 语句将阻塞，直到其中一个通道准备就绪。</li></ul></li><li><strong>随机选择</strong>:<ul><li>如果有多个 case 的通道都准备就绪，<code>select</code> 语句将随机选择一个 case 来执行。</li><li>这种随机选择有助于避免死锁和其他竞态条件。</li></ul></li><li><strong>case 表达式</strong>:<ul><li><code>select</code> 语句的每个 case 必须是一个通道操作，例如发送或接收。</li></ul></li></ol><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>除了<code>channel</code>，Go中还提供了一些重要的工具来协调goroutine之间的同步。<code>sync</code>包下的<code>WaitGroup</code>是其中之一。</p><p><code>WaitGroup</code>用于确保一些goroutine完成其任务后程序再执行其他内容。这里我们可以回顾一下全文的第一个代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">go</span> worker(i) <span class="comment">// 启动worker协程</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 阻塞主线程，等待所有worker完成</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Done.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>time.Sleep(5 * time.Second)</code>是用于阻塞主线程的进行，来确保goroutine执行完再打印最后的<code>&quot;Done.&quot;</code>。显然我们无法预测所有程序的goroutine执行所需的大概时间，所以这里使用<code>WaitGroup</code>可以更有效地同步协程与主线程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d started\n&quot;</span>, id)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d finished\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> <span class="number">5</span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;All workers finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码变换体现在<code>worker</code>函数和<code>main</code>函数中。<code>WaitGroup</code>本质上用一个<strong>计数器</strong>来实现协程的同步。接下来是对<code>WaitGroup</code>的三个方法的解释。</p><h3 id="WaitGroup-Add"><a href="#WaitGroup-Add" class="headerlink" title="WaitGroup.Add"></a>WaitGroup.Add</h3><p>用于向计数器添加一个计数值，表示当前任务列表中新值了多少任务（参数为负数时表示减少）。一般在你想协调的goroutine<strong>任务执行前</strong>调用<code>wg.Add(n)</code>。</p><p>最好不要使<code>Add</code>和<code>Wait</code>并发调用，否则有可能会达不到同步协程的效果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            doSomething()</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    doMain()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例子中，我们期望goroutine都执行完后执行<code>doMain()</code>，但实际上很有可能在goroutine开始执行前（执行<code>wg.Add(1)</code>前）就跳过了<code>wg.Wait()</code>，导致提前执行<code>doMain()</code>。</p><h3 id="WaitGroup-Done"><a href="#WaitGroup-Done" class="headerlink" title="WaitGroup.Done"></a>WaitGroup.Done</h3><p>用于让计数器减一，表示当前列表中有一个任务完成了。事实上，<code>wg.Done()</code>的底层实现就是<code>wg.Add(-1)</code>。一定要在每个goroutine完成任务后执行<code>wg.Done()</code>，否则会造成死锁。</p><p>当然执行了多余的<code>wg.Done()</code>也会导致死锁。</p><h3 id="WaitGroup-Wait"><a href="#WaitGroup-Wait" class="headerlink" title="WaitGroup.Wait"></a>WaitGroup.Wait</h3><p>执行函数时，检测当前计数器的值是否为0，不是则阻塞当前进程&#x2F;协程。</p><blockquote><p>在需要将<code>WaitGroup</code>变量传入协程函数时，要使用指针引入，而不是值引入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, wg sync.WaitGroup)</span></span> &#123; <span class="comment">// 值引入，Bad!</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// 看似wg.Done()执行了，实际上和main中的wg没关系。</span></span><br><span class="line">    doSomething()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> <span class="number">5</span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">    wg.Wait() <span class="comment">// wg没Done()过，死锁。</span></span><br><span class="line">fmt.Println(<span class="string">&quot;All workers finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>在进行并发操作时，对于临界区的操作需要通过加锁来实现并发安全。Golang标准包<code>sync</code>提供了两种锁：</p><ul><li>互斥锁（Mutex）</li><li>读写锁（RWMutex）</li></ul><h3 id="Mutex-1"><a href="#Mutex-1" class="headerlink" title="Mutex"></a>Mutex</h3><p><code>Mutex</code>就两个方法：<code>Lock()</code>和<code>Unlock()</code>，对临界区操作前<code>Lock()</code>，如果有其他goroutine获取的锁，当前goroutine阻塞，否则当前goroutine获得锁（信号量机制），操作结束后<code>Unlock()</code>。</p><p>这里给一个场景：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">cnt := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">cnt++</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(cnt) <span class="comment">// 97856</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于条件竞争，<code>cnt</code>并没有累加到100000。通过上锁就能解决问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">cnt := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">cnt++</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(cnt) <span class="comment">// 100000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h3><p><code>RWMutex</code>相比互斥锁，它允许多个读操作同时进行，但在写操作进行时，会阻塞所有的读操作和写操作。这样可以提高并发性能。</p><p><code>RWMutex</code>提供了四个方法：<code>RLock()</code>，<code>RUnlock()</code>，<code>Lock()</code>，<code>Unlock()</code>，前两者用于读操作，后两者用于写操作。使用方法与<code>Mutex</code>类似。</p><h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p><code>sync/atomic</code>包提供了Golang中的一些<strong>原子变量</strong>和<strong>原子操作</strong>。原子操作，即不会被分割的操作，作用上与互斥锁相似，但底层由CPU指令实现，不涉及加锁解锁，故性能高于互斥锁。原子变量则是用于执行原子操作的特殊变量。</p><p><code>sync/atomic</code>中原子操作一共有五类：</p><ul><li>读取（Load）</li><li>写入（Store）</li><li>交换（Swap）</li><li>比较并交换 （CompareAndSwap）</li><li>增减（Add）</li></ul><p><code>sync/atomic</code>中原子变量类型有以下几种：</p><ul><li>bool 布尔值</li><li>(u)int32 32位整型</li><li>(u)int64 64位整型</li><li>pointer 不可参与指针运算的指针</li><li>uinptr  无法持有对象的指针</li><li>value 空接口</li></ul><p>所有的原子变量都实现了前四类的原子操作方法（Load, Store, Swap, CompareAndSwap）,能参与加减运算的类型还实现了第五类原子操作方法（Add）</p><h3 id="原子操作函数"><a href="#原子操作函数" class="headerlink" title="原子操作函数"></a>原子操作函数</h3><p>原子操作函数中第一个参数往往是数据地址，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        wg sync.WaitGroup</span><br><span class="line">        count <span class="type">int64</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">for</span> _ = <span class="keyword">range</span> <span class="number">100000</span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">// atomic.AddInt64(addr *int64, delta int64)</span></span><br><span class="line">atomic.AddInt64(&amp;count, <span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(count) <span class="comment">// 100000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原子操作函数的操作对象限制在<code>(u)int32</code>,<code>(u)int64</code>,<code>uintptr</code>,<code>Pointer</code>上。</p><h3 id="原子操作方法"><a href="#原子操作方法" class="headerlink" title="原子操作方法"></a>原子操作方法</h3><p>官方文档更推荐使用原子变量，通过调用其方法来进行原子操作。这样比直接调用原子操作函数更加直观和不容易出错，支持的操作对象类型的更多。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        wg sync.WaitGroup</span><br><span class="line">        count atomic.Int64</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">for</span> _ = <span class="keyword">range</span> <span class="number">100000</span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">            count.Add(<span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">    fmt.Println(count.Load()) <span class="comment">// 100000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Golang中<code>context</code>可用来定义goroutine的上下文，用优雅的方式传递取消信号和设置超时。</p><h3 id="创建根节点Context"><a href="#创建根节点Context" class="headerlink" title="创建根节点Context"></a>创建根节点Context</h3><p>有两种方法创建空context：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line">ctx := context.TODO()</span><br></pre></td></tr></table></figure><p>两种方法能返回一个没有 deadline、没有取消函数的 <code>context.Context</code> 对象，只有语义的区别，即：</p><ul><li><strong><code>context.Background()</code></strong>:<ul><li>表示一个顶层或根上下文。</li><li>适用于程序启动时或作为顶级上下文来开始处理一个请求。</li><li>一般用于实际的生产代码中。</li></ul></li><li><strong><code>context.TODO()</code></strong>:<ul><li>表示一个待办事项上下文。</li><li>主要用于代码尚未完成时作为占位符。</li><li>不推荐在生产代码中使用。</li></ul></li></ul><h3 id="创建派生节点"><a href="#创建派生节点" class="headerlink" title="创建派生节点"></a>创建派生节点</h3><p>派生节点由根节点派生而来，用形如<code>WithXXX</code>格式的函数进行创建。</p><h4 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h4><p>创建一个带键值对的节点，同时保留父节点的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithValue(parent Context, key, val any) Context</span></span><br><span class="line">ctx := context.WithValue(context.Background(), <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">son := context.WithValue(ctx, <span class="string">&quot;son&quot;</span>, <span class="string">&quot;234567&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(ctx.Value(<span class="string">&quot;root&quot;</span>).(<span class="type">string</span>)) <span class="comment">// 123456</span></span><br><span class="line">fmt.Println(son.Value(<span class="string">&quot;son&quot;</span>).(<span class="type">string</span>)) <span class="comment">// 234567</span></span><br></pre></td></tr></table></figure><h4 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h4><p>创建一个派生节点和终止该节点执行的<code>cancel()</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">wg sync.WaitGroup</span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">)</span><br><span class="line">    <span class="comment">// WithCancel(ctx Context) (Context, CancelFunc)</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 生产者协程: 不断生成数据并放入通道直到消费者取消读取</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;生产者协程退出&quot;</span>)</span><br><span class="line">wg.Done()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;生产者协程生产了一个数据&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 消费者协程：消费10个数据后就取消任务</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(<span class="string">&quot;消费者协程消费了一个数据&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>ctx</code>就是消费者协程和生产者协程通信的桥梁。通过调用<code>cancel</code>函数，关闭与<code>ctx</code>关联的<code>done channel</code>，这样<code>case &lt;-ctx.Done()</code>就不再阻塞，可以执行关闭生产者的相关代码。父节点被取消后还会将取消消息传递给<strong>所有</strong>派生的子节点。</p><h4 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h4><p>在<code>WithCancel</code>的基础上，设置一个超时时间。被创建的子<code>context</code>会在指定的时间点自动关闭 <code>Done</code> 通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">deadline, err := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2024-12-3123:59:59&quot;</span>)\</span><br><span class="line"><span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// WithDeadline(ctx Context, d time.Time) (Context, CancelFunc)</span></span><br><span class="line">ctx, cancel := context.WithDeadline(context.Background(), deadline)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="comment">// 2024-12-31 23:59:59 才会结束程序</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(<span class="string">&quot;Context deadline exceeded&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h4><p>与<code>WithDeadline</code>类似，只不过接受一个持续时间而不是一个绝对时间。事实上<code>WithTimeout(1*time.Second)</code> 等同于 <code>WithDeadline(time.Now().Add(1*time.Second))</code></p><p>这里用生产者-消费者模型，来展示channel的基本使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer ，只写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">(id <span class="type">int</span>, ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Producer&quot;</span>, id, <span class="string">&quot;started&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> <span class="number">5</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Producer&quot;</span>, id, <span class="string">&quot;sent&quot;</span>, i)</span><br><span class="line">ch &lt;- i</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Producer&quot;</span>, id, <span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer ，只读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(id <span class="type">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Consumer&quot;</span>, id, <span class="string">&quot;started&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Consumer&quot;</span>, id, <span class="string">&quot;received&quot;</span>, res)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Consumer&quot;</span>, id, <span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动两个生产者和三个消费者</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">Producer(i, ch)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">Consumer(i, ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p><code>runtime</code>是Golang的核心组件之一，负责管理程序执行过程中的各种底层细节。这里只介绍一些和并发有关的接口。</p><ul><li><code>runtime.GOMAXPROCS(n)</code>: 设置最多可以并发运行的 CPU 数量。</li><li><code>runtime.Goexit()</code>: 使当前 Goroutine 退出。</li><li><code>runtime.Gosched()</code>: 让出当前 Goroutine 的 CPU 时间片，允许其他 Goroutine 运行。</li></ul><p>这些只是 <code>runtime</code> 包提供的众多功能中的一部分，对于更深入的了解和使用，请查阅官方文档和相关教程。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Grammar </tag>
            
            <tag> Concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django入门笔记</title>
      <link href="/2024/02/06/Django%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/02/06/Django%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Django的安装使用"><a href="#Django的安装使用" class="headerlink" title="Django的安装使用"></a>Django的安装使用</h2><h3 id="Django-安装"><a href="#Django-安装" class="headerlink" title="Django 安装"></a>Django 安装</h3><p>在pycharm里新建项目，在虚拟环境中下载Django包：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django</span><br></pre></td></tr></table></figure><p>安装之后可以通过以下指令打印Django的版本</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m django --version</span><br></pre></td></tr></table></figure><p>若终端打印出版本号说明Django安装成功</p><h3 id="创建Django项目"><a href="#创建Django项目" class="headerlink" title="创建Django项目"></a>创建Django项目</h3><p>打开终端并输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject demo .</span><br></pre></td></tr></table></figure><p>即可在本目录下创建项目名为<code>demo</code>的Django项目（无外层容器）</p><p>终端先进入<code>demo</code>目录下再输入启动命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ./demo</span><br><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><p>若成功运行Django服务器，说明Django项目创建成功。</p><h3 id="创建Django的一个App"><a href="#创建Django的一个App" class="headerlink" title="创建Django的一个App"></a>创建Django的一个App</h3><p>Django 中的App可理解为网站的某一应用功能，而这种应用功能可以应用独立的<em><strong>表结构、函数、HTML模板</strong></em>等等。一般网站只需一个APP即可</p><p>在终端输入以下命令创建App:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp web</span><br></pre></td></tr></table></figure><p>就可以创建一个名为<code>web</code>的App。</p><h3 id="Django项目结构说明"><a href="#Django项目结构说明" class="headerlink" title="Django项目结构说明"></a>Django项目结构说明</h3><p>使用<code>tree for windows</code>工具可打印目录树，命令与说明如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ tree HelloDjango -I &quot;.venv|*.md|__pycache__&quot;</span><br><span class="line"></span><br><span class="line">HelloDjango</span><br><span class="line">|-- db.sqlite3</span><br><span class="line">|-- demo</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- asgi.py             # 异步网络请求处理</span><br><span class="line">|   |-- settings.py         # 项目配置</span><br><span class="line">|   |-- urls.py             # url处理</span><br><span class="line">|   `-- wsgi.py             # 同步网络请求处理 </span><br><span class="line">|-- manage.py               # 提供命令行工具</span><br><span class="line">|-- requirements.txt</span><br><span class="line">`-- web                     # 我们创建的第一个app目录</span><br><span class="line">    |-- __init__.py</span><br><span class="line">    |-- admin.py            # Django自带的admin后台管理</span><br><span class="line">    |-- apps.py             # app启动类</span><br><span class="line">    |-- migrations          # 数据库字段变更记录</span><br><span class="line">    |   `-- __init__.py</span><br><span class="line">    |-- models.py           # 数据库操作</span><br><span class="line">    |-- tests.py            # 单元测试</span><br><span class="line">    `-- views.py            # 视图处理</span><br></pre></td></tr></table></figure><h2 id="视图入门篇"><a href="#视图入门篇" class="headerlink" title="视图入门篇"></a>视图入门篇</h2><h3 id="编写第一个视图"><a href="#编写第一个视图" class="headerlink" title="编写第一个视图"></a>编写第一个视图</h3><ol><li><p>在settings.py注册我们的app:</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">INSTALLED_APPS = [          <span class="comment"># 在这里注册我们的app</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;app.apps.AppConfig&#x27;</span>        <span class="comment"># 格式为&#123;App名&#125;.apps.&#123;App启动类名&#125;  </span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>编写URL和视图函数的对应关系(两种方法)</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo &gt; urls.py （全局url）</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> web <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">     path(<span class="string">&quot;/app/index/&quot;</span>, views.index)</span><br><span class="line">] </span><br></pre></td></tr></table></figure><p> 或者在应用下配置url</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># web &gt; urls.py </span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"> </span><br><span class="line">urlpatterns = [</span><br><span class="line">     path(<span class="string">&quot;index/&quot;</span>, views.index)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo &gt; urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">     path(<span class="string">&quot;app/&quot;</span>, include(<span class="string">&quot;web.urls&quot;</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>编写视图函数</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># web &gt; views.py    </span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):     <span class="comment"># 视图函数参数request用于处理用户请求，如request.GET, request.POST等等</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;Hello Django&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><p>之后启动项目即可访问<code>localhost:8000/app/index/</code>路径。</p><h3 id="模板-静态文件"><a href="#模板-静态文件" class="headerlink" title="模板&amp;静态文件"></a>模板&amp;静态文件</h3><p>配置好url和视图函数关系后，使用模板开启SSR应用：</p><ol><li><p>创建相关视图函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># web &gt; views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">page01</span>(<span class="params">request</span>):</span><br><span class="line">   <span class="keyword">return</span> render(request, render(<span class="string">&quot;page01.html&quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>编写html模板（模板文件放在web &gt; templates 或 demo &gt; templates下）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># web &gt; templates &gt; page01.html</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">title</span>&gt;</span>Page01<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/static/css/style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>Welcome to Page01<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入静态文件（静态文件放在与templates同级的static目录下）</p></li></ol><p><img src="/images/django/img.png" alt="img.png"></p><p>值得一提的是，Django中建议使用<code>&#123;% load static %&#125;</code>方法来引入静态文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;css/style.css&#x27; %&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;js/main.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中static路径在<code>setting.py</code>下可配置</p><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">templates</span>(<span class="params">request</span>):</span><br><span class="line">   title = <span class="string">&quot;Template Programmar&quot;</span></span><br><span class="line">   info = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;DopamineNone&quot;</span>, <span class="string">&quot;date&quot;</span>: <span class="string">&quot;2024.1.1&quot;</span>&#125;</span><br><span class="line">   content = [<span class="string">&quot;html 占位符&quot;</span>, <span class="string">&quot;render 传参&quot;</span>, <span class="string">&quot;列表参数&quot;</span>, <span class="string">&quot;字典参数&quot;</span>,<span class="string">&quot;循环渲染&quot;</span>]</span><br><span class="line">   <span class="keyword">return</span> render(request, <span class="string">&quot;templates.html&quot;</span>, &#123; <span class="string">&quot;title&quot;</span>: title, <span class="string">&quot;list&quot;</span>: content, <span class="string">&quot;dict&quot;</span>: info&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Template Programmar<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  占位符的基本使用  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 列表元素的使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; list &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; list.0 &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 列表的迭代 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        &#123;% for item in list %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 字典的引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; dict &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; dict.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; dict.date &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 字典的迭代 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--for key in dict.keys--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--for val in dict.values--&gt;</span></span><br><span class="line">        &#123;% for key, val in dict.items %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; key &#125;&#125; : &#123;&#123; val &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 条件语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        &#123;% if title == &quot;Template Programmar&quot;%&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>best!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        &#123;% elif title == &quot;Nothing&quot; %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>bad<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>worst<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="模板的继承"><a href="#模板的继承" class="headerlink" title="模板的继承"></a>模板的继承</h3><p>为了减少重复的html模板代码，提高模板复用率，我们可以使用模板的继承（类似Vue中的插槽）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--layout.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Layout<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        ....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在其他页面，我们只需写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--home.html--&gt;</span></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Page Home<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>这样我们就不必每个html都写基础的布局，只关心当前页面的主要内容即可</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问baidu函数对应的路径时会重定向到百度页面</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">baidu</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&quot;https://www.baidu.com/&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h3><p>假设用户有这么一个表单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/app/requests/&quot;</span>&gt;</span></span><br><span class="line">     &#123;% csrf_token %&#125; <span class="comment">&lt;!-- 解决跨域问题 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们处理请求参数可以用<code>request.POST.get(&quot;parameter&quot;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app &gt; views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">temp_request</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="built_in">print</span>(request.POST)</span><br><span class="line">    name = request.POST.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    pwd = request.POST.get(<span class="string">&quot;pwd&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;request.html&quot;</span>, &#123;<span class="string">&quot;name&quot;</span>: name, <span class="string">&quot;pwd&quot;</span>: pwd&#125;)</span><br></pre></td></tr></table></figure><h2 id="模型入门篇"><a href="#模型入门篇" class="headerlink" title="模型入门篇"></a>模型入门篇</h2><p>Django 自带SQLite3，我们能通过Django的orm框架操作数据库</p><h3 id="创建第一个数据库表"><a href="#创建第一个数据库表" class="headerlink" title="创建第一个数据库表"></a>创建第一个数据库表</h3><p>首先我们得写出模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">类名   -- 表名</span></span><br><span class="line"><span class="string">属性名 -- 字段名 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Question</span>(models.Model):</span><br><span class="line">    question_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    pub_date = models.DateTimeField(<span class="string">&quot;date published&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.question_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Choice</span>(models.Model):</span><br><span class="line">    question = models.ForeignKey(Question, on_delete=models.CASCADE)</span><br><span class="line">    choice_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    votes = models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.choice_text</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其次我们需要生成迁移文件(可理解为生成响应的SQL命令)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations </span><br></pre></td></tr></table></figure><p>最后我们执行未执行的迁移（执行模型对应的SQL命令）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>表就创建成功</p><h3 id="数据表的增删改查"><a href="#数据表的增删改查" class="headerlink" title="数据表的增删改查"></a>数据表的增删改查</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> web <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增数据</span></span><br><span class="line">models.Question.objects.create(question_text=<span class="string">&quot;What the hell?&quot;</span>) <span class="comment"># 有默认值的字段可不写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">table = models.Question.objects.<span class="built_in">all</span>() <span class="comment"># 列表，元素为行</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> table:</span><br><span class="line">   <span class="built_in">print</span>(item.question_text, <span class="string">&quot; &quot;</span>, item.pub_date)</span><br><span class="line"></span><br><span class="line">matched_list = models.Question.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">1</span>) <span class="comment"># 依旧是列表，最多有一项元素</span></span><br><span class="line">matched_el = models.Question.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">1</span>).first()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据</span></span><br><span class="line">models.Question.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">2</span>).delete()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新数据</span></span><br><span class="line">models.Question.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">1</span>).update(question_text=<span class="string">&quot;What the hell?&quot;</span>)</span><br></pre></td></tr></table></figure><p>学到这里，就可以用Django写出完整的web应用了。</p>]]></content>
      
      
      <categories>
          
          <category> Web 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 后端 </tag>
            
            <tag> Django </tag>
            
            <tag> Web 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 基础语法学习笔记</title>
      <link href="/2024/01/20/Golang%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/01/20/Golang%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<!-- Golang 知识清单 --><!-- 这篇博客仅是本人在学习Golang语法基础时的一些记录。 --><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul><li><p>关键词： <code>const</code></p></li><li><p>用法：</p><ol><li>单行声明：<code>const variableName [Type] = value</code></li><li>并行声明：<code>const p1, p2, p3 = v1, v2, v3</code></li><li>多行声明：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> beef, two, c = <span class="string">&quot;eat&quot;</span>, <span class="number">2</span>, <span class="string">&quot;veg&quot;</span></span><br><span class="line"><span class="keyword">const</span> Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Monday, Tuesday, Wednesday = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    Thursday, Friday, Saturday = <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="声明格式"><a href="#声明格式" class="headerlink" title="声明格式"></a>声明格式</h3><p>单行变量声明格式<code>var name [type] [= val]</code></p><p>多行变量声明格式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">bool</span></span><br><span class="line">    str <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>也可以同时给多个值声明类型：<code>var a, b, c int</code></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>若未显示初始赋值，则：</p><ul><li>int: 0</li><li>float: 0.0</li><li>string: 空字符串“”</li><li>bool: false</li><li>ptr: nil</li></ul><p>且声明时变量未声明类型，则编译器会通过初始赋值推导变量赋值；当然，未声明类型的变量必需得初始赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Right</span></span><br><span class="line"><span class="keyword">var</span> userName = <span class="string">&quot;Joe&quot;</span> <span class="comment">// Go变量命名遵循小驼峰命名法</span></span><br><span class="line"><span class="keyword">var</span> lottery <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> temp <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">var</span> unknow</span><br></pre></td></tr></table></figure><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><p>学过C的都懂。</p><p>Go中通过<code>&amp;</code>运算符来得到变量的地址。</p><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p><code>Printf()</code>函数可以在fmt包外使用，可以向控制台打印格式化字符串，同C语言的<code>printf()</code>和Go的<code>fmt.Sprintf()</code>。</p><p><code>fmt.Print()</code>和<code>fmt.Println()</code>的作用一致，使用%v对字符串进行格式化，<code>fmt.Println()</code>会多打印一个\n。</p><h3 id="初始赋值运算符"><a href="#初始赋值运算符" class="headerlink" title=":&#x3D; 初始赋值运算符"></a>:&#x3D; 初始赋值运算符</h3><p>可以使用<code>:=</code>来高效地进行变量声明和初始化。</p><p><code>var num = 10</code>就可以简写为<code>num := 10</code>。</p><p><strong>注意</strong>： 对同一个变量只能使用一次<code>:=</code>运算符，否则会报错；对已声明但未使用的局部变量也会出现报错；在变量声明前使用变量也会报错。</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li>bool</li><li>int&#x2F;uint&#x2F;uintptr<ul><li>int&#x2F;uint 长度与操作系统位数相等, int16&#x2F;int32&#x2F;int64间不能隐式转化，常量除外。</li><li>uintptr 长度足够存放一个指针。</li></ul></li><li>float32&#x2F;float64 <strong>(没有float和double!!! 尽量用float64)</strong></li><li>byte (int8的别名，字符)， 自行了解utf8包。</li><li>string <strong>(Go中字符串没有以’\0’)</strong>, 自行了解strings和strconv包。</li><li>ptr <strong>(Go中指针运算是非法的)</strong></li></ul><h3 id="变量运算"><a href="#变量运算" class="headerlink" title="变量运算"></a>变量运算</h3><p>运算符同C语言；唯一需注意的是带有<code>++</code>、<code>--</code>运算符只能当作语句，像<code>sum = i++</code>这种语句在Go中不合法。</p><p>符号优先级优先级     运算符</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7      ^ !</span><br><span class="line">6      * / % &lt;&lt; &gt;&gt; &amp; &amp;^</span><br><span class="line">5      + - | ^</span><br><span class="line">4      == != &lt; &lt;= &gt;= &gt;</span><br><span class="line">3      &lt;-</span><br><span class="line">2      &amp;&amp;</span><br><span class="line">1      ||</span><br></pre></td></tr></table></figure><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><h3 id="if-else-结构"><a href="#if-else-结构" class="headerlink" title="if-else 结构"></a>if-else 结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">    <span class="comment">// do something </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">    <span class="comment">// do something else    </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// catch-all or default</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> val := <span class="number">10</span>; val &gt; max &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>花括号{}无论如何都不能省略</li><li>{与关键字同一行，}也与关键字同一行</li><li>条件中可包含初始化语句</li></ol><h3 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a>switch 结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch 的第一种形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 空分支，只有当 i == 0 时才会进入分支</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        f() <span class="comment">// 当 i == 0 时函数不会被调用</span></span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        DoSomething()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        f() <span class="comment">// 当 i == 0 时函数也会被调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch 的第二种形式</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> condition1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> condition2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  switch 的第三种形式</span></span><br><span class="line"><span class="keyword">switch</span> initialization &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-结构"><a href="#for-结构" class="headerlink" title="for 结构"></a>for 结构</h3><ol><li>基于计数器的for语句结构：<code>for 初始化语句; 条件语句; 修饰语句 &#123;&#125;</code></li><li>基于条件判断的for语句:<code>for 条件语句 &#123;&#125;</code></li><li>无限循环: <code>for &#123;&#125;</code></li><li>for-range结构: <code>for ix, val := range coll &#123; &#125;</code>， <strong>注意</strong>val只是对coll中值的拷贝</li></ol><h3 id="goto-结构"><a href="#goto-结构" class="headerlink" title="goto 结构"></a>goto 结构</h3><p>配合标签使用，不建议使用goto语句</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Go中一共有三种函数：</p><ol><li>具名函数</li><li>匿名函数 (Lambda)</li><li>方法</li></ol><p>而且Go允许一个函数A作为另个函数B的参数传入，只要A的返回值数量和类型与B函数参数一致</p><p>Go 禁止函数重载</p><p>Go中申明一个在外部定义的函数，你只需要给出函数名与函数签名，不需要给出函数体，如<code>func flushICache(begin, end uintptr)</code></p><h3 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h3><h4 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h4><p>传参有两种方式：</p><ol><li>按值传参</li><li>引用传参</li></ol><p>推荐使用引用传参，一般比按值传参有更小的性能开支</p><p>具有多个参数的函数也能直接传入一个包含多个变量的slice作为参数</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>返回值有一些特性</p><ol><li>可命名可匿名，使用多个匿名返回值或单个及其以上的命名返回值时需要用()括起来</li><li>使用命名返回值则return语句可不带参数</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> numx2, numx3 <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numx2, numx3 = getX2AndX3(num)</span><br><span class="line">    PrintValues()</span><br><span class="line">    numx2, numx3 = getX2AndX3_2(num)</span><br><span class="line">    PrintValues()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintValues</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;num = %d, 2x num = %d, 3x num = %d\n&quot;</span>, num, numx2, numx3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getX2AndX3</span><span class="params">(input <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * input, <span class="number">3</span> * input</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getX2AndX3_2</span><span class="params">(input <span class="type">int</span>)</span></span> (x2 <span class="type">int</span>, x3 <span class="type">int</span>) &#123;</span><br><span class="line">    x2 = <span class="number">2</span> * input</span><br><span class="line">    x3 = <span class="number">3</span> * input</span><br><span class="line">    <span class="comment">// return x2, x3</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空白符"><a href="#空白符" class="headerlink" title="空白符"></a>空白符</h4><p>空白符<code>_</code>，用于匹配不需要的函数返回值</p><h4 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h4><p>变长参数类型用<code>...type</code>表示，如<code>func myFunc(a, b, arg ...int) &#123;&#125;</code>，该类型和slice很像，可用for迭代。</p><h4 id="defer与追踪"><a href="#defer与追踪" class="headerlink" title="defer与追踪"></a>defer与追踪</h4><p>defer 关键字允许我们在函数返回返回值前才执行某些语句。defer 与 return之间执行顺序是： 先为返回值赋值，再执行defer，最后返回返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    function1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;In function1 at the top\n&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> function2()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;In function1 at the bottom!\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;function2: Deferred until the end of the calling function!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print Results</span></span><br><span class="line"><span class="comment">// In Function1 at the top</span></span><br><span class="line"><span class="comment">// In Function1 at the bottom!</span></span><br><span class="line"><span class="comment">// Function2: Deferred until the end of the calling function!</span></span><br></pre></td></tr></table></figure><p>当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出）</p><p>这样我们就能通过defer关键字实现代码追踪，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="type">string</span>)</span></span>   &#123; fmt.Println(<span class="string">&quot;entering:&quot;</span>, s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">untrace</span><span class="params">(s <span class="type">string</span>)</span></span> &#123; fmt.Println(<span class="string">&quot;leaving:&quot;</span>, s) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    trace(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> untrace(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;in a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    trace(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> untrace(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;in b&quot;</span>)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>详情见 <a href="https://learnku.com/docs/the-way-to-go/built-in-function/3603">内置函数</a></p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>基本与C语言一致。Go语言中允许相互调用的递归函数，这些函数的声明顺序是随意的。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>这里放个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// make an Add2 function, give it a name p2, and call it:</span></span><br><span class="line">    p2 := Add2()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Call Add2 for 3 gives: %v\n&quot;</span>, p2(<span class="number">3</span>))</span><br><span class="line">    <span class="comment">// make a special Adder function, a gets value 2:</span></span><br><span class="line">    TwoAdder := Adder(<span class="number">2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The result is: %v\n&quot;</span>, TwoAdder(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add2</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b + <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Adder</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><h4 id="数组声明格式"><a href="#数组声明格式" class="headerlink" title="数组声明格式"></a>数组声明格式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier [<span class="built_in">len</span>]<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>像让数组接收任意类型的元素需要使用空接口作为类型</p><p>Go 中数组是值类型（不是指针），故可通过<code>new()</code>创建，如<code>new([5]int)</code>。</p><p>通过<code>var</code>和<code>new()</code>分别创建的数组arr1和arr2的区别是:</p><ul><li>arr1类型是*[5]int</li><li>arr2类型是[5]int</li></ul><h4 id="数组常量"><a href="#数组常量" class="headerlink" title="数组常量"></a>数组常量</h4><p>有三种形式：</p><ul><li><code>[5]int&#123;1,2,3,5,6&#125;</code></li><li><code>[...]int&#123;1,2,3,4,6&#125;</code></li><li><code>[5]int&#123;3: 4, 5: 6&#125;</code></li></ul><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p><code>[4][4]int</code></p><h4 id="数组传递给函数"><a href="#数组传递给函数" class="headerlink" title="数组传递给函数"></a>数组传递给函数</h4><p><code>func demo(a *[3]int)&#123;&#125;</code></p><h4 id="数组相等"><a href="#数组相等" class="headerlink" title="数组相等"></a>数组相等</h4><p>数组相等判断规则：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v1 := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;</span><br><span class="line">v2 := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;</span><br><span class="line">v3 := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Python&quot;</span>&#125;</span><br><span class="line">v4 := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Python&quot;</span>&#125;</span><br><span class="line">v5 := []<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;</span><br><span class="line">v6 := []<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(v1 == v2) <span class="comment">// true</span></span><br><span class="line">fmt.Println(v1 == v3) <span class="comment">// false 元素顺序不同</span></span><br><span class="line">fmt.Println(v1 == v4) <span class="comment">// false 元素个数不同</span></span><br><span class="line"><span class="comment">// fmt.Println(v1 == v5) mismatch types: [3]string and []string</span></span><br><span class="line"><span class="comment">// fmt.Println(v5 == v6) slice can only be compared with nil</span></span><br><span class="line"><span class="comment">// fmt.Println(v3 == v5) mismatch types: [3]string and []string</span></span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><blockquote><p>切片（slice）是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型（因此更类似于 C&#x2F;C++ 中的数组类型，或者 Python 中的 list 类型）。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Equal Expression</span></span><br><span class="line">slice[:] == slice</span><br><span class="line">slice[:n] == slice[<span class="number">0</span>:n]</span><br><span class="line">slice[n:] == slice[n:<span class="built_in">len</span>(slice)]</span><br></pre></td></tr></table></figure><h4 id="cap-–数组容量"><a href="#cap-–数组容量" class="headerlink" title="cap() –数组容量"></a>cap() –数组容量</h4><p>切片是长度可变的数组， <code>0 &lt;= len(s) &lt;= cap(s)</code>，其中<code>cap()</code>用于返回s切片的容量。多个相关的切片是共享数据的。</p><h4 id="切片传递给函数"><a href="#切片传递给函数" class="headerlink" title="切片传递给函数"></a>切片传递给函数</h4><p><code>func demo(a []int)&#123;&#125;</code></p><h4 id="make-创建切片"><a href="#make-创建切片" class="headerlink" title="make() 创建切片"></a>make() 创建切片</h4><p><code>var slice []type = make([]type, len, [cap])</code></p><p>new和make的区别：</p><ul><li>new是分配新的空间，返回的是指针</li><li>make是返回初始值，只使用于数组，map和channel</li></ul><h4 id="bytes-包"><a href="#bytes-包" class="headerlink" title="bytes 包"></a>bytes 包</h4><p>提供操作<code>[]byte</code>类型方法的包</p><h4 id="for-range"><a href="#for-range" class="headerlink" title="for-range"></a>for-range</h4><p>for-range句式用于遍历slice，其中ix为索引，value为索引值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ix, value := <span class="keyword">range</span> slice1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复制与追加"><a href="#复制与追加" class="headerlink" title="复制与追加"></a>复制与追加</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slice1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">slice2 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">n := <span class="built_in">copy</span>(slice1, slice2)</span><br><span class="line">fmt.Print(n, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">fmt.Print(slice1)</span><br><span class="line"></span><br><span class="line">slice2 = <span class="built_in">append</span>(slice2, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Print(slice2)</span><br></pre></td></tr></table></figure><h4 id="sort-包"><a href="#sort-包" class="headerlink" title="sort 包"></a>sort 包</h4><p>Go提供了sort包来实现各种切片的排序，如<code>sort.Ints(a []int)</code>, <code>sort.Strings(s string)</code></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map-声明格式"><a href="#Map-声明格式" class="headerlink" title="Map 声明格式"></a>Map 声明格式</h3><p>Map的声明格式为<code>var m map[keytype]valuetype</code></p><p>keytype 只能为简单类型如<code>int</code>,<code>string</code>, <code>float</code>等，切片和结构不能作为keytype,未初始化的值为<code>nil</code>。</p><p>用<code>make()</code>初始化map变量，而不是用<code>new()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mf := <span class="keyword">map</span>[<span class="type">int</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">10</span> &#125;,</span><br><span class="line">        <span class="number">2</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">20</span> &#125;,</span><br><span class="line">        <span class="number">5</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">50</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(mf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查键和删键"><a href="#查键和删键" class="headerlink" title="查键和删键"></a>查键和删键</h3><p>用<code>val, isPresent = m[&quot;key&quot;]</code>中的<code>isPresent</code>可以判断键值<code>key</code>是否存在。</p><p>用<code>delete(m, key)</code>可以删键，且key不存在也不会报错</p><h3 id="Map与for-range"><a href="#Map与for-range" class="headerlink" title="Map与for-range"></a>Map与for-range</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h2><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>如<code>fmt</code>,<code>os</code>常用功能的150+内置包称作标准库。常见标准库看<a href="https://learnku.com/docs/the-way-to-go/overview-of-the-91-standard-library/3626">这里</a></p><h3 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h3><ul><li><p>有<code>Match</code>方法：<code>ok, _ := regexp.Match(pat, searchIn)</code></p></li><li><p>同样有<code>MatchString</code>方法</p></li><li><p>创建正则对象：<code>re, _ = regexp.Compile(pat)</code></p></li><li><p>替换字符串： <code>str := re.ReplaceAllString(pat, new)</code></p></li><li><p>按函数替换字符串： <code>str := re.ReplaceAllStringFunc(pat, f)</code></p></li></ul><h3 id="锁和sync"><a href="#锁和sync" class="headerlink" title="锁和sync"></a>锁和sync</h3><p>为避免同一变量同时被不同线程访问修改造成资源竞争，我们需要对变量上一个线程锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> count <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">        mu.Lock() <span class="comment">// 加锁，保护count</span></span><br><span class="line">        count++</span><br><span class="line">        mu.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有<code>RWMutex</code>锁，使用<code>RLock()</code>来允许同时有多个线程对变量进行读操作，只有一个线程进行写操作</p><h3 id="精密计算big包"><a href="#精密计算big包" class="headerlink" title="精密计算big包"></a>精密计算big包</h3><p>Go提供了<code>big</code>包来进行精确计算。</p><ul><li><code>big.NewInt(n)</code></li><li><code>big.NewRat(N, D)</code> N为分子，D为分母</li></ul><h3 id="自定义包"><a href="#自定义包" class="headerlink" title="自定义包"></a>自定义包</h3><p>包文件名应由短小的不含<code>_</code>的单词组成</p><p>想使用包得先通过<code>import</code>关键字导入包： <code>import &quot;relative path or URL&quot;</code></p><ul><li><p><code>import &quot;package&quot;</code></p><p>使用包的全局变量和函数需通过<code>包名.val</code>和<code>包名.func</code></p></li><li><p><code>import . &quot;package&quot;</code></p><p>可直接使用包的全局变量和函数</p></li><li><p><code>import _ &quot;package&quot;</code></p><p>只导入包的副作用，即调用init函数和初始化全局变量</p></li><li><p><code>import alias &quot;package&quot;</code></p><p>导入包并使用<code>alias</code>别名</p></li></ul><p>格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pack_demo包</span></span><br><span class="line"><span class="keyword">package</span> packdemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pi <span class="type">float32</span> = <span class="number">3.14514</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数入口</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;./pack_demo&quot;</span> <span class="comment">// 同一路径下</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(packdemo.pi)</span><br><span class="line">    packdemo.HelloWorld()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构与方法"><a href="#结构与方法" class="headerlink" title="结构与方法"></a>结构与方法</h2><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> identifier <span class="keyword">struct</span> &#123;</span><br><span class="line">    field1 type1</span><br><span class="line">    field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明结构体变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s T</span><br><span class="line">s.a = <span class="number">5</span></span><br><span class="line">s.b = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// use new()</span></span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line">t = <span class="built_in">new</span>(T)</span><br></pre></td></tr></table></figure><p>值得注意的是，Go中无论是结构体变量还算结构体指针都通过<code>.</code>选择器符来引用结构体字段。</p><p>更简短的初始化结构体实例为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">demo := &amp;struct1&#123;<span class="number">10</span>, <span class="number">1.5</span>, <span class="string">&quot;no&quot;</span>&#125; <span class="comment">// 本质是使用new()</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> demo struct1</span><br><span class="line">demo = struct1&#123;<span class="number">10</span>, <span class="number">1.5</span>, <span class="string">&quot;no&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>Go中结构体的内存分布是连续块存在的。</p><p>结构体中的转化只存在于有相同底层类型的结构体间，而且得通过显式转化。</p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="type">int</span>, name <span class="type">string</span>)</span></span> *File &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;File&#123;fd, name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用工厂方法创建结构体实例</span></span><br><span class="line">f := NewFile(<span class="number">10</span>, <span class="string">&quot;./test.txt&quot;</span>) </span><br></pre></td></tr></table></figure><p>在Go中，标识符以大写字符开头的能被外部包的代码所引用，否则对外部包不可见。通过这个能使一个结构体设置为私有类型，只能通过工厂方法创建和操作结构体。</p><p>通过<code>make()</code>创建结构体会报错。</p><h3 id="结构体中的标签"><a href="#结构体中的标签" class="headerlink" title="结构体中的标签"></a>结构体中的标签</h3><p>用于自省类型、文档标记等。可通过<code>reflect</code>包来获取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TagType <span class="keyword">struct</span> &#123; <span class="comment">// tags</span></span><br><span class="line">    field1 <span class="type">bool</span>   <span class="string">&quot;An important answer&quot;</span></span><br><span class="line">    field2 <span class="type">string</span> <span class="string">&quot;The name of the thing&quot;</span></span><br><span class="line">    field3 <span class="type">int</span>    <span class="string">&quot;How much there are&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tt := TagType&#123;<span class="literal">true</span>, <span class="string">&quot;Barak Obama&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        refTag(tt, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">refTag</span><span class="params">(tt TagType, ix <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    ttType := reflect.TypeOf(tt)</span><br><span class="line">    ixField := ttType.Field(ix)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, ixField.Tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名字段和内嵌结构体"><a href="#匿名字段和内嵌结构体" class="headerlink" title="匿名字段和内嵌结构体"></a>匿名字段和内嵌结构体</h3><p>匿名字段可用于模拟结构体的继承，即通过内嵌匿名结构体来模拟。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> innerS <span class="keyword">struct</span> &#123;</span><br><span class="line">    in1 <span class="type">int</span></span><br><span class="line">    in2 <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> outerS <span class="keyword">struct</span> &#123;</span><br><span class="line">    b    <span class="type">int</span></span><br><span class="line">    c    <span class="type">float32</span></span><br><span class="line">    <span class="type">int</span>  <span class="comment">// anonymous field</span></span><br><span class="line">    innerS <span class="comment">//anonymous field</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    outer := <span class="built_in">new</span>(outerS)</span><br><span class="line">    outer.b = <span class="number">6</span></span><br><span class="line">    outer.c = <span class="number">7.5</span></span><br><span class="line">    outer.<span class="type">int</span> = <span class="number">60</span></span><br><span class="line">    outer.in1 = <span class="number">5</span></span><br><span class="line">    outer.in2 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;outer.b is: %d\n&quot;</span>, outer.b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;outer.c is: %f\n&quot;</span>, outer.c)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;outer.int is: %d\n&quot;</span>, outer.<span class="type">int</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;outer.in1 is: %d\n&quot;</span>, outer.in1)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;outer.in2 is: %d\n&quot;</span>, outer.in2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构体字面量</span></span><br><span class="line">    outer2 := outerS&#123;<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">60</span>, innerS&#123;<span class="number">5</span>, <span class="number">10</span>&#125;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;outer2 is:&quot;</span>, outer2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名冲突时：</p><ul><li>外层名字会覆盖内层名字</li><li>同一级别出现两次相同的名字会报错</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Go 中方法是作用在receiver上的函数。定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span></span> methodName(parameter_list) (return_value_list) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>无论recv是实例还是指针，都通过<code>object.funcName()</code>调用方法。</p><p>不需要recv的值可以用<code>_</code>代替：<code>func (_ receiver_type) methodName(parameter_list) (return_value_list) &#123; ... &#125;</code></p><p>值得注意的是类型和作用其上的方法必需在同一包中，这也是为什么不能在int,float等类型上定义方法。</p><p>结构体内嵌和自己在同一个包中的结构体时，可以彼此访问对方所有的字段和方法。</p><h3 id="类型的String-方法"><a href="#类型的String-方法" class="headerlink" title="类型的String()方法"></a>类型的String()方法</h3><p>为结构体定义<code>String()</code>方法可以使<code>fmt.Printf()</code>的%v输出或<code>fmt.Print()</code>和<code>fmt.Println()</code>的默认输出</p><h3 id="垃圾回收和SetFinalizer"><a href="#垃圾回收和SetFinalizer" class="headerlink" title="垃圾回收和SetFinalizer"></a>垃圾回收和SetFinalizer</h3><p><code>runtime.GC()</code>可以显式调用垃圾收集器</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><ul><li><p>类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。</p></li><li><p>实现某个接口的类型（除了实现接口方法外）可以有其他的方法。</p></li><li><p>一个类型可以实现多个接口。</p></li><li><p>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stockPosition <span class="keyword">struct</span> &#123;</span><br><span class="line">    ticker     <span class="type">string</span></span><br><span class="line">    sharePrice <span class="type">float32</span></span><br><span class="line">    count      <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* method to determine the value of a stock position */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stockPosition)</span></span> getValue() <span class="type">float32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.sharePrice * s.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> car <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">make</span>  <span class="type">string</span></span><br><span class="line">    model <span class="type">string</span></span><br><span class="line">    price <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* method to determine the value of a car */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c car)</span></span> getValue() <span class="type">float32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* contract that defines different things that have value */</span></span><br><span class="line"><span class="keyword">type</span> valuable <span class="keyword">interface</span> &#123;</span><br><span class="line">    getValue() <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showValue</span><span class="params">(asset valuable)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Value of the asset is %f\n&quot;</span>, asset.getValue())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> o valuable = stockPosition&#123;<span class="string">&quot;GOOG&quot;</span>, <span class="number">577.20</span>, <span class="number">4</span>&#125;</span><br><span class="line">    showValue(o)</span><br><span class="line">    o = car&#123;<span class="string">&quot;BMW&quot;</span>, <span class="string">&quot;M3&quot;</span>, <span class="number">66500</span>&#125;</span><br><span class="line">    showValue(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>检查断言的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// varI 是接口类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// uncheck type</span></span><br><span class="line">v := varI.(T) <span class="comment">// 若varI含类型T的值，则v为varI转化为T的值，否则v为T类的零值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;</span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用Go中特有的<code>type-switch</code>语句来判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> t := varI.(<span class="keyword">type</span>) &#123; <span class="comment">// 这里的type画重点！！</span></span><br><span class="line">    <span class="keyword">case</span> type1:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> type2: </span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体类型是值类型还算引用类型取决于该类的接口实现使用的接收者类型（雾</p><p>判断某个值是否实现某个接口也可以用<code>varT.(I)</code>的方法来判断，这里不多赘述</p><p>Go 语言规范定义了接口方法集的调用规则：</p><ul><li>类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集</li><li>类型 T 的可调用方法集包含接受者为 T 的所有方法</li><li>类型 T 的可调用方法集不包含接受者为 *T 的方法</li></ul><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>任何类型都实现了空接口，所以可以这样做：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> any Any</span><br><span class="line">any = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">fmt.Println(any)</span><br><span class="line">any = <span class="number">15</span></span><br><span class="line">fmt.Println(any)</span><br><span class="line">any = <span class="number">1.05</span></span><br><span class="line">fmt.Println(any)</span><br><span class="line">any = <span class="built_in">new</span>(Person&#123;name: <span class="string">&quot;Bob&quot;</span>, age: <span class="number">100</span>&#125;)</span><br><span class="line">fmt.Println(any.name, <span class="string">&quot; &quot;</span>, any.age)</span><br></pre></td></tr></table></figure><p>将切片数据复制到空接口切片只能通过<code>for-range</code>语句显式赋值</p><h2 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h2><h3 id="读取用户输入"><a href="#读取用户输入" class="headerlink" title="读取用户输入"></a>读取用户输入</h3><ul><li><code>fmt.Scanln(&amp;str1, &amp;str2, ...)</code>从标准输入依次读取以空格分割的字符串，直到遇到<code>\n</code></li><li><code>fmt.Scanf(format, &amp;str1)</code></li><li><code>fmt.Sscan(str, &amp;str1, &amp;str2, ...)</code> 从字符串读取</li></ul><p>还能用bufio包提供的缓冲读取来实现读取输入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">)</span><br><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">input, err := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>通过<code>os</code>包的<code>Open()</code>函数能得到文件的句柄</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import (&quot;os&quot;, &quot;bufio&quot;)</span></span><br><span class="line">inputFile, inputError := os.Open(<span class="string">&quot;path/to/file&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> inputError != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Report FileNotFound Error</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Remember close the file in the end!!!</span></span><br><span class="line"><span class="keyword">defer</span> inputFile.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the file</span></span><br><span class="line">inputReader := bufio.NewReader(inputFile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">// Infinite loop until EOF</span></span><br><span class="line">    inputStr, readerError := inputReader.ReaderString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> readerError == io.EOF &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用<code>io/ioutil</code>将整个文件内容读到一个字节切片（<code>[]byte</code>）中,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import (&quot;io/ioutil&quot;)</span></span><br><span class="line"></span><br><span class="line">inputFile, err := ioutil.ReadFiler(<span class="string">&quot;path/to/file&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Error Handling</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ioutil.WriteFile(<span class="string">&quot;path/to/file&quot;</span>, buf, max_length) <span class="comment">// 可命名文件名</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Error Handling</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带缓冲的读取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">n, err := inputReader.Read(buf) <span class="comment">// n为读到的字节数</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;<span class="keyword">break</span>&#125;</span><br></pre></td></tr></table></figure><p><code>Fscanln</code>读取文件数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inputFile --- file handler</span></span><br><span class="line">_, err := fmt.Fscanln(file, &amp;v1, &amp;v2, &amp;v3)</span><br></pre></td></tr></table></figure><p>切片读文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n是字符数， f是文件句柄， buf是读取到文件内容的切片</span></span><br><span class="line">n, err := f.Read(buf[:])</span><br></pre></td></tr></table></figure><p>写文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;data.txt&quot;</span>, os.O_WRONLY|os.O_CREATE, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">if</span> outputError != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;An error occurred with file opening or creation\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> outputFile.Close()</span><br><span class="line"></span><br><span class="line">outputWriter := bufio.NewWriter(outputFile)</span><br><span class="line">outputString := <span class="string">&quot;hello world!\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">    outputWriter.WriteString(outputString)</span><br><span class="line">&#125;</span><br><span class="line">outputWriter.Flush() <span class="comment">// 重点！！！</span></span><br></pre></td></tr></table></figure><p>使用<code>io</code>包的<code>Copy(dst, src)</code>函数可以实现文件的拷贝，其中dst和src是文件句柄。</p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>通过<code>os.Args</code>可以获取命令行参数的切片(<code>os.Args[0]</code>是程序名)</p><p><code>flag</code>包也能处理命令行参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag.Bool(flag, bool, demonstration)</span></span><br><span class="line"><span class="keyword">var</span> isN *<span class="type">bool</span> = flag.Bool(<span class="string">&quot;n&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;default demonstrations&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArgs(); i++ &#123;</span><br><span class="line">    fmt.Println(flag.Arg(i))</span><br><span class="line">    <span class="keyword">if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSON数据"><a href="#JSON数据" class="headerlink" title="JSON数据"></a>JSON数据</h3><p>Go中用<code>encoding/json</code>包来处理json数据</p><p>Go结构体 &#x3D;&gt; JSON</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adr <span class="keyword">struct</span> &#123;</span><br><span class="line">    Country  <span class="type">string</span></span><br><span class="line">    Province <span class="type">string</span></span><br><span class="line">    Code     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dic <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    Age     <span class="type">int</span></span><br><span class="line">    Address *Adr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowJson</span><span class="params">(demo *Dic)</span></span> &#123;</span><br><span class="line">    json, _ := json.Marshal(demo) <span class="comment">// 序列化</span></span><br><span class="line">    fmt.Println(json)</span><br><span class="line">    <span class="keyword">var</span> res *Dic</span><br><span class="line">    _ := json.Unmarshal(json, res)</span><br><span class="line">    fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    demo := &amp;Dic&#123;Name: <span class="string">&quot;Dopa&quot;</span>, Age: <span class="number">18</span>, Address: &amp;Adr&#123;<span class="string">&quot;China&quot;</span>, <span class="string">&quot;Fujian&quot;</span>, <span class="number">200</span>&#125;&#125;</span><br><span class="line">    ShowJson(demo)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;&quot;Name&quot;:&quot;Dopa&quot;,&quot;Age&quot;:18,&quot;Address&quot;:&#123;&quot;Country&quot;:&quot;China&quot;,&quot;Province&quot;:&quot;Fujian&quot;,&quot;Code&quot;:200&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>Go中与JSON对应的数据结构：</p><ul><li>bool 对应 JSON 的 booleans</li><li>float64 对应 JSON 的 numbers</li><li>string 对应 JSON 的 strings</li><li>nil 对应 JSON 的 null</li></ul><p>编码Map对象需要是map[string] T类型</p><p>Channel,复杂类型不能被编码</p><p>map[string]interface{}和[]interface{}能解码任何JSON对象和数组</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="定义错误"><a href="#定义错误" class="headerlink" title="定义错误"></a>定义错误</h3><p>Go中提供了<code>errors</code>包来定义错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> NotFoundErr <span class="type">error</span> = errors.New(<span class="string">&quot;File not found&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(NotFoundErr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用<code>fmt.Errorf()</code>创建错误对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := fmt.Errorf(<span class="string">&quot;usage: %s&quot;</span>, something)</span><br></pre></td></tr></table></figure><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>Go中用<code>panic</code>产生运行时异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">&quot;error.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;Fail to Open File&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从panic恢复"><a href="#从panic恢复" class="headerlink" title="从panic恢复"></a>从panic恢复</h3><p>在多次嵌套调用的函数中触发panic使defer 语句保证执行并且控制权交给panic调用的函数。栈会被展开直到defer语句中的recover()被调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protect</span><span class="params">(g <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;run time err : %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    log.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们就能用闭包处理错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;error&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConvertInt64ToInt</span><span class="params">(input <span class="type">int64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> math.MinInt32 &lt;= input &amp;&amp; input &lt;= math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">int</span>(input)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%d is out of the int32 range&quot;</span>, input))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntFromInt64</span><span class="params">(input <span class="type">int64</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;%v&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ConvertInt64ToInt(input), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="单元测试和基准测试"><a href="#单元测试和基准测试" class="headerlink" title="单元测试和基准测试"></a>单元测试和基准测试</h3><p>测试代码的包文件名满足这种形式<code>*_test.go</code>，且必需导入<code>testing</code>包，写一些Test*开头的全局函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAbcde</span><span class="params">(t *testing.T)</span></span></span><br></pre></td></tr></table></figure><p>一些二通知测试失败的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Fail() <span class="comment">// 标记测试函数为失败，然后继续执行（剩下的测试）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> FailNow() <span class="comment">// 标记测试函数为失败并中止执行；文件中别的测试也被略过，继续执行下一个文件。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Log(args ...<span class="keyword">interface</span>&#123;&#125;) <span class="comment">// args 被用默认的格式格式化并打印到错误日志中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Fatal(args ...<span class="keyword">interface</span>&#123;&#125;) <span class="comment">//     结合 先执行Log，然后执行FailNow的效果。</span></span><br></pre></td></tr></table></figure><p>使用<code>go test</code>来编译测试程序，并执行所有Test*的函数，所有函数通过会打印PASS</p><p>做简单的基准测试需要测试代码中包含Benchmark<em>的函数并接收一个</em>testing.B类型的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkReverse</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令 go test –test.bench&#x3D;.* 会运行所有的基准测试函数；代码中的函数会被调用 N 次（N 是非常大的数，如 N &#x3D; 1000000），并展示 N 的值和函数执行的平均时间，单位为 ns（纳秒，ns&#x2F;op）。</p><h3 id="表驱动测试"><a href="#表驱动测试" class="headerlink" title="表驱动测试"></a>表驱动测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tests = []<span class="keyword">struct</span>&#123;   <span class="comment">// Test table</span></span><br><span class="line">    in  <span class="type">string</span></span><br><span class="line">    out <span class="type">string</span></span><br><span class="line"></span><br><span class="line">&#125;&#123;</span><br><span class="line">    &#123;“in1”, “exp1”&#125;,</span><br><span class="line">    &#123;“in2”, “exp2”&#125;,</span><br><span class="line">    &#123;“in3”, “exp3”&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunction</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        s := FuncToBeTested(tt.in)</span><br><span class="line">        <span class="keyword">if</span> s != tt.out &#123;</span><br><span class="line">            t.Errorf(“%d. %q =&gt; %q, wanted: %q”, i, tt.in, s, tt.out)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协程与通道"><a href="#协程与通道" class="headerlink" title="协程与通道"></a>协程与通道</h2><h3 id="并发、并行和协程"><a href="#并发、并行和协程" class="headerlink" title="并发、并行和协程"></a>并发、并行和协程</h3><ol><li>一个应用程序是运行在机器上的一个进程，进程是一个运行在自己内存地址空间里的独立执行体。</li><li>一个进程由一个或多个操作系统线程组成，线程其实是共享同一个内存地址空间的一起工作的执行体。</li><li>协程运行在线程之上，协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程。</li><li>Go使用<code>go</code>关键字就能开启协程，要注意若主线程先结束，未结束的协程也会中断。</li></ol><h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p>用GOMAXPROCS 为一个大于默认值 1 的数值来允许运行时支持使用多于 1 个的操作系统线程，否则所有的协程都会共享同一个线程。</p><p>协程的数量 &gt; 1 + GOMAXPROCS &gt; 1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel类型本质是队列。声明格式为<code>var identifier chan datatype</code>，之后必需实例化它：<code>identifer = make(chan datatype)</code></p><p>用<code>var identifier &lt;- chan datatype</code>声明只读通道， <code>var identifier chan &lt;- datatype</code>声明只写通道。</p><p>通道操作符为<code>&lt;-</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch &lt;- <span class="number">100</span> <span class="comment">// 向ch写入100</span></span><br><span class="line">fmt.Println(&lt;- ch) <span class="comment">// 100</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ch)) <span class="comment">// 0; 100被取出</span></span><br></pre></td></tr></table></figure><blockquote><p>通道阻塞： 当通道数据已满且没有接收者读出数据&#x2F;通道已空仍有接收者尝试读出数据，就会触发通道阻塞，直到数据被读出&#x2F;通道读入新数据</p></blockquote><p>遍历channel:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// 阻塞管道后才能遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一 自动检测管道是否被阻塞</span></span><br><span class="line"><span class="keyword">for</span> val := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    dosomethings()   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二 用ok判断管道是否被阻塞</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    val, ok := &lt;- ch</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    dosomethings()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误的方法！</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ch); i++ &#123;</span><br><span class="line">    <span class="comment">// len(ch)会变化！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用select语句切换协程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> u:= &lt;- ch1:</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">case</span> v:= &lt;- ch2:</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// no value ready to be received</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果都阻塞了，会等待直到其中一个可以处理</span></span><br><span class="line"><span class="comment">// 如果多个可以处理，随机选择一个</span></span><br><span class="line"><span class="comment">// 如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的（这就是准备好了，可以执行）。</span></span><br></pre></td></tr></table></figure><h3 id="sync包的WaitGroup"><a href="#sync包的WaitGroup" class="headerlink" title="sync包的WaitGroup"></a>sync包的WaitGroup</h3><p>WaitGroup 用于创建任务队列，其中提供了三个方法<code>WaitGroup.Add(count)</code>、<code>WaitGroup.Done()</code>、<code>WaitGroup.Wait()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> waitGroup sync.WaitGroup</span><br><span class="line">    waitGroup.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> waitGroup.Done()</span><br><span class="line">        doSomethings()</span><br><span class="line">    &#125;()</span><br><span class="line">    waitGroup.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;main end!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Grammar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 笔记</title>
      <link href="/2024/01/20/Grammar-for-Javascript/"/>
      <url>/2024/01/20/Grammar-for-Javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本博客仅是本人学习原生Js时的一些记录和总结。<br><span style="color: #ff6d91">注意：</span><code>console.log(string)</code>用于向控制台打印string字符串，是示例中最常用到的代码之一。</p><h2 id="数据类型及其字面量"><a href="#数据类型及其字面量" class="headerlink" title="数据类型及其字面量"></a>数据类型及其字面量</h2><p>EMCAscript规定了7大简单&#x2F;原始数据类型：</p><ul><li>Boolean 布尔值</li><li>String 字符串</li><li>Number 数值 <em>包括整型和浮点数</em></li><li>null 空值 <em>注意大小写区分，NULL和Null不是null类型</em></li><li>undefined 未定义值</li><li>BigInt 大整型数</li><li>Symbol 一种独特且不可修改的类型</li></ul><p>还有Object 这种复杂数据类型</p><p>可以使用<code>typeof x</code>来判断变量的数据类型</p><p>字面量是直接在代码中的固定值，这里记录一些不同数据类型字面量的特点</p><h3 id="整型与进制（Integer-BigInt）"><a href="#整型与进制（Integer-BigInt）" class="headerlink" title="整型与进制（Integer &amp; BigInt）"></a>整型与进制（Integer &amp; BigInt）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">117</span>, <span class="number">123456789123456789n</span>             (decimal, base <span class="number">10</span>, no prefix)</span><br><span class="line"><span class="number">015</span>, <span class="number">0001</span>, <span class="number">0o777777777777n</span>              (octal, base <span class="number">8</span>, prefix： <span class="number">0</span> or 0o)</span><br><span class="line"><span class="number">0x1123</span>, <span class="number">0x00111</span>, <span class="number">0x123456789ABCDEFn</span>     (hexadecimal, <span class="string">&quot;hex&quot;</span> or base <span class="number">16</span>, <span class="attr">prefix</span>: 0x)</span><br><span class="line"><span class="number">0b11</span>, <span class="number">0b0011</span>, <span class="number">0b11101001010101010101n</span>   (binary, base <span class="number">2</span>, <span class="attr">prefix</span>: 0b)</span><br><span class="line"><span class="comment">// 以n作为后缀的为BigInt类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">0o777777777777n</span> === <span class="string">&#x27;bigint&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>格式为<code>[digits].[digits][(E|e)[(+|-)]digits]</code>,以下为例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1415926</span></span><br><span class="line"><span class="number">.123456789</span></span><br><span class="line"><span class="number">3.1E+12</span></span><br><span class="line"><span class="number">.1e-23</span>  <span class="comment">// 1e-24</span></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串模板语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;DopamineNone&#x27;</span></span><br><span class="line"><span class="keyword">const</span> string = <span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span> <span class="comment">// My name is DopamineNone</span></span><br></pre></td></tr></table></figure><h3 id="数组：多余的逗号"><a href="#数组：多余的逗号" class="headerlink" title="数组：多余的逗号"></a>数组：多余的逗号</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, , <span class="number">3</span>,,]</span><br><span class="line"><span class="comment">// a为[1, &lt;empty item&gt;, 3, &lt;empty item&gt;]， 最后一个非空白项后的最后一个逗号会被忽略</span></span><br><span class="line"><span class="comment">// 这里a数组的长度为4，其中访问a[1], a[3]返回的都是undefined</span></span><br><span class="line"><span class="comment">// 但&lt;empty item&gt;不等同于undefined，当对数组a使用遍历函数如map或forEach时，这些空白项会被跳过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a 的更推荐写法</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="comment">/* empty */</span>, <span class="number">3</span>, <span class="comment">/* empty */</span>,]</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>, <span class="literal">undefined</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组字面量支持多行书写</span></span><br><span class="line"><span class="keyword">let</span> a = [</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象的属性名可以是任何字符串和数字，其中不是合法标识符的属性名只能通过[“property-name”]来索引。例子demo如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sales = <span class="string">&quot;Toyota&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">carTypes</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> name === <span class="string">&quot;Honda&quot;</span> ? name : <span class="string">`Sorry, we don&#x27;t sell <span class="subst">$&#123;name&#125;</span>.`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">const</span> demo = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: <span class="title function_">carTypes</span>(<span class="string">&#x27;Alice&#x27;</span>), <span class="comment">// 函数返回值赋值</span></span><br><span class="line">    <span class="string">&#x27;c&#x27;</span>: sales, <span class="comment">// 变量赋值</span></span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&#x27;</span>:  <span class="string">&#x27;Blank&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;!&#x27;</span>: <span class="string">&#x27;Exclamation Mark&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// right</span></span><br><span class="line">demo[<span class="string">&#x27;a&#x27;</span>] <span class="comment">// Alice</span></span><br><span class="line">demo.<span class="property">a</span> <span class="comment">// Alice</span></span><br><span class="line">demo.<span class="property">B</span> <span class="comment">// Sorry, we don&#x27;t sell Alice.</span></span><br><span class="line">demo[<span class="string">&#x27;B&#x27;</span>] <span class="comment">// Sorry, we don&#x27;t sell Alice.</span></span><br><span class="line">demo[<span class="number">1</span>] <span class="comment">// Bob</span></span><br><span class="line">demo[<span class="string">&#x27;1&#x27;</span>] <span class="comment">// Bob</span></span><br><span class="line">demo[<span class="string">&#x27;&#x27;</span>] <span class="comment">// Blank</span></span><br><span class="line">demo[<span class="string">&#x27;!&#x27;</span>] <span class="comment">// Exclamation Mark</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wrong</span></span><br><span class="line">demo<span class="number">.1</span></span><br><span class="line">demo.<span class="string">&#x27;&#x27;</span></span><br><span class="line">demo.<span class="string">&#x27;!&#x27;</span></span><br></pre></td></tr></table></figure><p>对象字面量还允许直接写入__proto__、对象方法，以及支持同名属性简写、属性名计算等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> demo = &#123;</span><br><span class="line">    id, <span class="comment">// shorthand for &#x27;id: id&#x27;</span></span><br><span class="line">    <span class="attr">__proto__</span>: theProtoObj,</span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// Super calls</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;d &quot;</span> + <span class="variable language_">super</span>.<span class="title function_">toString</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Computed (dynamic) property names</span></span><br><span class="line">    [<span class="string">&quot;prop_&quot;</span> + (<span class="function">() =&gt;</span> <span class="number">42</span>)()]: <span class="number">42</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有其他数据类型的字面量如Boolean(布尔值)的字面量只有<code>true</code>和<code>false</code>，<span style="color: #ff6d91">注意大小写！</span>，还有RagExp(正则表达式)、Symbol等类型，会放在后面章节详细讨论。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Javascript中想使用变量就得对其先进行声明，其中声明变量有三个方法&#x2F;关键字：</p><ul><li>var</li><li>let</li><li>const</li></ul><blockquote><p>三者区别：const用于声明常量，常量变量不可修改值（对象、数组等复杂变量另说），对应的let和var声明的变量可修改值。const和let声明的变量具有块作用域，var没有。使用建议const &gt; let &gt; var。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一些例子</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// 无块作用域</span></span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">5</span>; <span class="comment">// 有块作用域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// x is 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure><blockquote><p>变量提升: 指无论变量在哪被声明，声明都会被提升至其作用域的顶部，但不会同时初始化。const和let声明的变量也存在变量提升，但其将作用域顶部至代码中它被声明的位置被设为“暂时性死区”，在“暂时性死区”使用该变量会抛出ReferenceError。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> v === <span class="string">&#x27;undefined&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码等同于 -&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v; <span class="comment">// 声明但未赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> v === <span class="string">&#x27;undefined&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">v = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ******* 分割线 ******* */</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> v === <span class="string">&#x27;undefined&#x27;</span>); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> v = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码可理解为于 -&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v; <span class="comment">// 声明但未赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> v === <span class="string">&#x27;undefined&#x27;</span>); <span class="comment">// ReferenceError, 暂时性死区</span></span><br><span class="line">v = <span class="number">5</span>;  </span><br></pre></td></tr></table></figure><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="常见运算符"><a href="#常见运算符" class="headerlink" title="常见运算符"></a>常见运算符</h3><ul><li>赋值运算符： &#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;</li><li>自增运算符： ++, – <em>分为前置和后置</em></li><li>比较运算符： &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;, &#x3D;&#x3D;(undefined &#x3D;&#x3D; null is true, 2&#x3D;&#x3D;’2’is true), &#x3D;&#x3D;&#x3D;(<em>类型和值都相等</em>, NaN!&#x3D;&#x3D;NaN is true), !&#x3D;, !&#x3D;&#x3D;</li><li>逻辑运算符： &amp;&amp;, ||, !</li><li>位运算符：&amp;, |, ^, ~</li><li>三元运算符： condition ? res1 : res2</li></ul><blockquote><p>优先级：() &gt;&gt; ++ – ! &gt;&gt; * &#x2F; % &gt;&gt; +- &gt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D; &gt;&gt; &#x3D;&#x3D; !&#x3D; &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D; &gt;&gt; &amp;&amp; &gt;&gt; || &gt;&gt; &#x3D; &gt;&gt; ,</p></blockquote><p><span style="color: #ff6d91">注意：</span>NaN表示计算错误，对NaN的任何操作返回NaN</p><h3 id="其他运算符号"><a href="#其他运算符号" class="headerlink" title="其他运算符号"></a>其他运算符号</h3><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>delete运算符用于删除对象的属性（极其不建议删除数组元素）,成功返回true，失败返回false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">delete</span> obj[key]</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">key2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="keyword">delete</span> <span class="title class_">Math</span>.<span class="property">PI</span>; <span class="comment">// returns false (cannot delete non-configurable properties)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObj = &#123; <span class="attr">h</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">delete</span> myObj.<span class="property">h</span>; <span class="comment">// returns true (can delete user-defined properties)</span></span><br></pre></td></tr></table></figure><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>返回变量的数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFun = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;5 + 2&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> shape = <span class="string">&quot;round&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> size = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> foo = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>, <span class="string">&quot;Orange&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">obj</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> myFun; <span class="comment">// returns &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> shape; <span class="comment">// returns &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> size; <span class="comment">// returns &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> foo; <span class="comment">// returns &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> today; <span class="comment">// returns &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> doesntExist; <span class="comment">// returns &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> obj.<span class="property">name</span> <span class="comment">// returns &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> obj.<span class="property">getName</span> <span class="comment">// return &quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// predefined objects</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Date</span>; <span class="comment">// returns &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Function</span>; <span class="comment">// returns &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Math</span>; <span class="comment">// returns &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Option</span>; <span class="comment">// returns &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">String</span>; <span class="comment">// returns &quot;function&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arrays</span></span><br><span class="line"><span class="keyword">const</span> trees = [<span class="string">&quot;redwood&quot;</span>, <span class="string">&quot;bay&quot;</span>, <span class="string">&quot;cedar&quot;</span>, <span class="string">&quot;oak&quot;</span>, <span class="string">&quot;maple&quot;</span>];</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> trees; <span class="comment">// returns true</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> trees; <span class="comment">// returns true</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">in</span> trees; <span class="comment">// returns false</span></span><br><span class="line"><span class="string">&quot;bay&quot;</span> <span class="keyword">in</span> trees; <span class="comment">// returns false</span></span><br><span class="line"><span class="comment">// (you must specify the index number, not the value at that index)</span></span><br><span class="line"><span class="string">&quot;length&quot;</span> <span class="keyword">in</span> trees; <span class="comment">// returns true (length is an Array property)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// built-in objects</span></span><br><span class="line"><span class="string">&quot;PI&quot;</span> <span class="keyword">in</span> <span class="title class_">Math</span>; <span class="comment">// returns true</span></span><br><span class="line"><span class="keyword">const</span> myString = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;coral&quot;</span>);</span><br><span class="line"><span class="string">&quot;length&quot;</span> <span class="keyword">in</span> myString; <span class="comment">// returns true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom objects</span></span><br><span class="line"><span class="keyword">const</span> mycar = &#123; <span class="attr">make</span>: <span class="string">&quot;Honda&quot;</span>, <span class="attr">model</span>: <span class="string">&quot;Accord&quot;</span>, <span class="attr">year</span>: <span class="number">1998</span> &#125;;</span><br><span class="line"><span class="string">&quot;make&quot;</span> <span class="keyword">in</span> mycar; <span class="comment">// returns true</span></span><br><span class="line"><span class="string">&quot;model&quot;</span> <span class="keyword">in</span> mycar; <span class="comment">// returns true</span></span><br></pre></td></tr></table></figure><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof 用于判断某个对象是否是某个对象类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectName <span class="keyword">instanceof</span> objectType</span><br></pre></td></tr></table></figure><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>super 用于调用对象父级的属性，详细见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super">super</a></p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组解构</span></span><br><span class="line"><span class="keyword">const</span> foo = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> [one, two, three] = foo; </span><br><span class="line"><span class="comment">// 对象解构</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">key1</span>: <span class="string">&#x27;val1&#x27;</span>,</span><br><span class="line">    <span class="attr">key2</span>: <span class="string">&#x27;val2&#x27;</span>,</span><br><span class="line">    <span class="attr">key3</span>: <span class="string">&#x27;val3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;key1, key2, key3&#125; = obj</span><br></pre></td></tr></table></figure><h3 id="运算中的转化"><a href="#运算中的转化" class="headerlink" title="运算中的转化"></a>运算中的转化</h3><ul><li>undefined 会转化为 NaN 或 false</li><li>null 会转化为 0 或 false</li><li>数值与字符串<br>由 字符串和数值组成的，仅由 <strong>+</strong> 链接的表达式，数值都会被自动转化为字符串，其余情况数值不会发生自动转化。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#x27;+&#x27; expression</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I&#x27;m &quot;</span> + <span class="number">18</span>) <span class="comment">// &quot;I&#x27;m 18&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">18</span> + <span class="string">&#x27; is my age&#x27;</span>) <span class="comment">// &#x27;18 is my age&#x27;</span></span><br><span class="line"><span class="comment">// other expression</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">18</span> - <span class="string">&#x27;9&#x27;</span>) <span class="comment">// 9 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">18</span> - <span class="string">&#x27;九&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>可以用<code>parseInt(string, radix)</code>和<code>parseFloat(string)</code>函数将字符串分别转化为整型和浮点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;18&#x27;</span>) <span class="comment">// 18</span></span><br><span class="line"><span class="comment">// 以0~9开头的字符串仅被转化为开头字符组成的数值</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;18is my age&#x27;</span>) <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;18&lt;114514&#x27;</span>) <span class="comment">// 18</span></span><br><span class="line"><span class="comment">// 若对浮点数值的字符串使用parseInt()会导致小数点精度丢失</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;18.999is my age&#x27;</span>) <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;18.999is my age&#x27;</span>) <span class="comment">// 18.999</span></span><br><span class="line"><span class="comment">// parseInt(string, radix) 接收的第二个参数是进制数，默认为10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;111&#x27;</span>, <span class="number">2</span>) <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1f&#x27;</span>, <span class="number">16</span>) <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>还能用<code>BigInt()</code>方法将字符串或数值转为大整型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">BigInt</span>(<span class="number">123</span>) <span class="comment">// 123n</span></span><br><span class="line"><span class="title class_">BigInt</span>(<span class="string">&quot;-12873263826387216387213&quot;</span>) <span class="comment">// -12873263826387216387213n</span></span><br></pre></td></tr></table></figure><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>这里着重记录分支语句与循环语句</p><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><p>与C&#x2F;Java写法一致，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if 分支语句</span></span><br><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">  statement1;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">  statement2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (conditionN) &#123;</span><br><span class="line">  statementN;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  statementLast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch 分支语句</span></span><br><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="attr">label1</span>:</span><br><span class="line">    statements1;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="attr">label2</span>:</span><br><span class="line">    statements2;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    statementsDefault;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里着重记录Javascript中的可自动转化为false值的变量：</p><ul><li>false</li><li>undefined</li><li>null</li><li>0</li><li>NaN</li><li>“”, 空字符串</li></ul><h3 id="意外处理语句"><a href="#意外处理语句" class="headerlink" title="意外处理语句"></a>意外处理语句</h3><p>我们可以用throw语句或try…catch语句处理程序意外。  </p><ul><li><p>throw 语句<br>什么数据类型都能被throw，但一般用Number和String来描述报错。<br>已有的报错类型有：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#error_types">ECMAScript exceptions</a></li><li>DOMException<br>throw的语法就是<code>throw expression</code></li></ul></li><li><p>try…catch 语句<br>在try块中执行语句，若出现报错，控制流转到catch块进行报错处理,最后都会执行finally块中的内容，以下为一个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">openMyFile</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">writeMyFile</span>(theData); <span class="comment">// This may throw an error</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(e.<span class="property">name</span>) <span class="comment">// 报错名</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(e.<span class="property">message</span>) <span class="comment">// 报错信息</span></span><br><span class="line">  <span class="title function_">handleError</span>(e); <span class="comment">// If an error occurred, handle it</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="title function_">closeMyFile</span>(); <span class="comment">// Always close the resource</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// finally中的返回作为整个语句的返回，能复写try/catch中的throw报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>与C&#x2F;Java写法基本一致（但javascript循环中没有goto语句），如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="keyword">for</span> (initialization; condition; afterthought) &#123;</span><br><span class="line">      statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while 循环</span></span><br><span class="line"><span class="keyword">while</span> (condition)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do while 循环</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><p>但javascript有labeled语句，一般与break,continue配合使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">foo</span>: &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;face&quot;</span>);</span><br><span class="line">  <span class="keyword">break</span> foo;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this will not be executed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;swap&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will log:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;face&quot;</span></span><br><span class="line"><span class="comment">// &quot;swap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******分割线********/</span></span><br><span class="line"><span class="keyword">var</span> allPass = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="attr">top</span>: <span class="keyword">for</span> (i = <span class="number">0</span>; items.<span class="property">length</span>; i++)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tests.<span class="property">length</span>; i++)</span><br><span class="line">    <span class="keyword">if</span> (!tests[j].<span class="title function_">pass</span>(items[i])) &#123;</span><br><span class="line">      allPass = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span> top;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><p>迭代语句一般用于遍历数组和对象两种复杂数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for ... in 迭代语句</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The key <span class="subst">$&#123;key&#125;</span> to the value in obj is <span class="subst">$&#123;obj[key]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for ... of 迭代语句</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或用Object.entries(obj)方法解构迭代对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, val] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj))&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>js中函数声明格式如下，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcName</span>(<span class="params">parameter1, parameter2, ...</span>)&#123;</span><br><span class="line">    statement;</span><br><span class="line">    <span class="keyword">return</span> something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">funcName</span>(p1, p2, ...)</span><br></pre></td></tr></table></figure><p>因为函数的声明也会被提升，所以在函数声明前调用函数是没问题的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">1</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color: #ff6d91">注意：</span> 函数表达式不会被提升，如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">1</span>)) <span class="comment">//  ReferenceError</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="keyword">function</span> (<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数作用域与闭包"><a href="#函数作用域与闭包" class="headerlink" title="函数作用域与闭包"></a>函数作用域与闭包</h3><p>函数内定义的变量为局部变量，无法在函数外直接得到，除非使用闭包。而函数内则访问局部变量和全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">closure</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> v3 = <span class="number">3</span>;  <span class="comment">// 若这里将v3重命名为v2，func1内的v2将无法闭包</span></span><br><span class="line">        <span class="keyword">return</span> &#123;v1, v2, v3&#125;; <span class="comment">// v1、v2、v3都能访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// func1 内访问不到v3</span></span><br><span class="line">    <span class="keyword">return</span> closure</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v1) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v2, v3) <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">const</span> closure = <span class="title function_">func1</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">closure</span>()) <span class="comment">// &#123; v1: 1, v2: 2, v3: 3&#125;</span></span><br></pre></td></tr></table></figure><h3 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h3><p>arguments对象是每个函数都有的存储所有传参的类数组-对象,示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [pp, p1, p2, p3] = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showArguments</span>(<span class="params"><span class="keyword">default</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> params = [pp, p1, p2, p3] <span class="comment">// 解构传参</span></span><br><span class="line"><span class="title function_">showArguments</span>(...params) <span class="comment">// &#123; 0: 0, 1: 1, 2: 2, 3: 3&#125;</span></span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b = <span class="number">1</span></span>) &#123;    <span class="comment">// 默认参数一定写在非默认参数之后</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showRestParams</span>(<span class="params">param1, ...param2</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(param2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showRestParams</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><h3 id="Number-Math-Date"><a href="#Number-Math-Date" class="headerlink" title="Number &amp; Math &amp; Date"></a>Number &amp; Math &amp; Date</h3><h4 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h4><p>内置的Number对象预置了一些常用属性和方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number 属性</span></span><br><span class="line"><span class="keyword">const</span> biggestNum = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line"><span class="keyword">const</span> smallestNum = <span class="title class_">Number</span>.<span class="property">MIN_VALUE</span>;</span><br><span class="line"><span class="keyword">const</span> infiniteNum = <span class="title class_">Number</span>.<span class="property">POSITIVE_INFINITY</span>;</span><br><span class="line"><span class="keyword">const</span> negInfiniteNum = <span class="title class_">Number</span>.<span class="property">NEGATIVE_INFINITY</span>;</span><br><span class="line"><span class="keyword">const</span> notANum = <span class="title class_">Number</span>.<span class="property">NaN</span>;</span><br><span class="line"><span class="comment">// Number 方法</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseFloat</span>()</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>()</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>()</span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>()</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>()</span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">isSafeInteger</span>()</span><br><span class="line"><span class="comment">// Number 原型的方法</span></span><br><span class="line">someNum.<span class="title function_">toExponential</span>(precision) <span class="comment">// 小数点后精确度</span></span><br><span class="line">somNum.<span class="title function_">toFixed</span>(precision) <span class="comment">// 小数点后精确度</span></span><br><span class="line">somNum.<span class="title function_">toPrecision</span>(precision) <span class="comment">// 有效数位</span></span><br></pre></td></tr></table></figure><p>更多见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number#static_properties">详情</a></p><h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h4><p>Math内置了很多数学常量和数学函数，一般需要时查表使用即可。</p><p>一般属性和方法有<code>Math.PI</code>,<code>Math.sin()</code>等。</p><p>更多见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math#static_properties">详情</a>。</p><h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newDate = <span class="title class_">Date</span>() <span class="comment">// 表示当下的时间的字符串</span></span><br><span class="line"><span class="keyword">const</span> newDate2 = <span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">// 创建当下时间的对象实例</span></span><br><span class="line"><span class="keyword">const</span> newDate3 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;1999-9-9&#x27;</span>) <span class="comment">// 创建1999-9-9T0:0:0:0的对象示例</span></span><br><span class="line"><span class="keyword">const</span> newDate4 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1995</span>, <span class="number">11</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999</span>); <span class="comment">// Set day and month</span></span><br><span class="line"></span><br><span class="line">newDate.<span class="title function_">getFullYear</span>() <span class="comment">// 2024, 年份</span></span><br><span class="line">newDate.<span class="title function_">getMonth</span>() <span class="comment">// 注意： getMonth()方法得到是月数-1，比如一月是0</span></span><br><span class="line">newDate.<span class="title function_">getDate</span>() <span class="comment">// 仅日期</span></span><br><span class="line">newDate.<span class="title function_">getTime</span>() <span class="comment">// 时间戳</span></span><br><span class="line"></span><br><span class="line">newDate.<span class="title function_">parse</span>(dateString) <span class="comment">// 返回dateString对应的时间戳</span></span><br><span class="line"></span><br><span class="line">newDate.<span class="property">set</span>...() <span class="comment">// get对应的set都有</span></span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">target.<span class="title function_">indexOf</span>(pattern, position=<span class="number">0</span>) <span class="comment">// pattern在target中position之后的位置首次出现的位置</span></span><br><span class="line">target.<span class="title function_">lastIndexOf</span>(pattern)</span><br><span class="line"></span><br><span class="line">target.<span class="title function_">startsWith</span>(pattern, position=<span class="number">0</span>)</span><br><span class="line">target.<span class="title function_">endsWith</span>(pattern, position=<span class="number">0</span>)</span><br><span class="line">target.<span class="title function_">includes</span>(pattern, position=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">str0.<span class="title function_">concat</span>(str1, ..., strN) <span class="comment">// 返回拼接后的字符串但不改变target</span></span><br><span class="line">target.<span class="title function_">split</span>(separator, limit) <span class="comment">// 返回数组</span></span><br><span class="line">target.<span class="title function_">slice</span>(start, end = target.<span class="property">length</span>) <span class="comment">// 切片，start, end可以是负数</span></span><br><span class="line">target.<span class="title function_">substring</span>(start, end) <span class="comment">// 负数作0处理，小数作起点，大数作终点</span></span><br><span class="line"></span><br><span class="line">target.<span class="title function_">match</span>(regex) <span class="comment">// 返回一个数组，包括input,index,groups</span></span><br><span class="line">target.<span class="title function_">matchAll</span>(regex) <span class="comment">// 返回一个迭代器，可用for of迭代， regex必需开启g全局，否则会报错</span></span><br><span class="line"></span><br><span class="line">target.<span class="title function_">replace</span>(regex/string, newString)</span><br><span class="line">target.<span class="title function_">replaceAll</span>(regex/string, newString)</span><br><span class="line">target.<span class="title function_">search</span>(regexp) <span class="comment">// 返回下标，找不到返回-1</span></span><br><span class="line"></span><br><span class="line">target.<span class="title function_">toLowerCase</span>()</span><br><span class="line">target.<span class="title function_">toUpperCase</span>()</span><br><span class="line"></span><br><span class="line">target.<span class="title function_">repear</span>(count) <span class="comment">// 重复拼接自身</span></span><br><span class="line"></span><br><span class="line">target.<span class="title function_">trim</span>() <span class="comment">// 去除前后的空白</span></span><br></pre></td></tr></table></figure><p>String的详细方法见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#static_methods">详情</a></p><p>还有一些和国际化标准有关的类：<code>Intl.DateTimeFormat</code>,<code>Intl.NumberFormat</code>,<code>Intl.Collator</code></p><h3 id="Regex-正则表达式"><a href="#Regex-正则表达式" class="headerlink" title="Regex 正则表达式"></a>Regex 正则表达式</h3><h4 id="正则表达式字面量"><a href="#正则表达式字面量" class="headerlink" title="正则表达式字面量"></a>正则表达式字面量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则表达式的字面量以 / content / 表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边界符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ^:开始</span></span><br><span class="line">/^java/.<span class="title function_">test</span>(<span class="string">&quot;javascript&quot;</span>) <span class="comment">// true</span></span><br><span class="line">/^script/.<span class="title function_">test</span>(<span class="string">&quot;javascript&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// $:结束</span></span><br><span class="line">/java$/.<span class="title function_">test</span>(<span class="string">&quot;javascript&quot;</span>) <span class="comment">// false</span></span><br><span class="line">/script$/.<span class="title function_">test</span>(<span class="string">&quot;javascript&quot;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">/^java$/.<span class="title function_">test</span>(<span class="string">&quot;java&quot;</span>) <span class="comment">// true</span></span><br><span class="line">/^java$/.<span class="title function_">test</span>(<span class="string">&quot;javajava&quot;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 量词</span></span><br><span class="line"><span class="comment">// * &gt;= 0次</span></span><br><span class="line">/^java*$/.<span class="title function_">test</span>(<span class="string">&#x27;javaa&#x27;</span>) <span class="comment">// true </span></span><br><span class="line">/^java*$/.<span class="title function_">test</span>(<span class="string">&#x27;jav&#x27;</span>) <span class="comment">// true </span></span><br><span class="line"><span class="comment">// + &gt;= 1次</span></span><br><span class="line">/^java+$/.<span class="title function_">test</span>(<span class="string">&#x27;java&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/^java+$/.<span class="title function_">test</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// ？== 0次或1次</span></span><br><span class="line">/^java?$/.<span class="title function_">test</span>(<span class="string">&#x27;java&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/^java?$/.<span class="title function_">test</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// &#123;n&#125; == n次</span></span><br><span class="line">/^java&#123;<span class="number">1</span>&#125;$/.<span class="title function_">test</span>(<span class="string">&#x27;javajava&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/^java&#123;<span class="number">2</span>&#125;$/.<span class="title function_">test</span>(<span class="string">&#x27;javajava&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// &#123;n,&#125; &gt;= n次</span></span><br><span class="line">/^java&#123;<span class="number">1</span>，&#125;$/.<span class="title function_">test</span>(<span class="string">&#x27;javajava&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/^java&#123;<span class="number">1</span>,&#125;$/.<span class="title function_">test</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false </span></span><br><span class="line"><span class="comment">// m次 &gt;= &#123;n, m&#125; &gt;= n次 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符类</span></span><br><span class="line">/[abc]/，出现其中一个字符就返回<span class="literal">true</span> </span><br><span class="line">/^[abc]$/.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>) <span class="literal">false</span>, 只能三个中的一个 </span><br><span class="line">/^[abc]&#123;<span class="number">2</span>&#125;$/.<span class="title function_">test</span>(<span class="string">&#x27;ab&#x27;</span>) <span class="literal">true</span>. </span><br><span class="line">/^[a-zA-<span class="variable constant_">Z0</span>-<span class="number">9</span>]$/ 表示所有大小写字母和数字中的一个 </span><br><span class="line">/[^a-z]/除小写字母</span><br><span class="line">.匹配除了换行符外的其他任何符号 </span><br><span class="line"><span class="comment">// 预定义：</span></span><br><span class="line">\d， 相当于<span class="number">0</span>-<span class="number">9</span> </span><br><span class="line">\D, 相当于[^<span class="number">0</span>-<span class="number">9</span>] </span><br><span class="line">\w，任意字母数字下划线 </span><br><span class="line">\W，[^\w]  </span><br><span class="line"><span class="comment">// 修饰符</span></span><br><span class="line">/i 不区分大小写</span><br><span class="line">/g 全局</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grammar </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些 Golang 的内置包</title>
      <link href="/2024/01/20/%E4%B8%80%E4%BA%9BGolang%20%E7%9A%84%E5%86%85%E7%BD%AE%E5%8C%85/"/>
      <url>/2024/01/20/%E4%B8%80%E4%BA%9BGolang%20%E7%9A%84%E5%86%85%E7%BD%AE%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><blockquote><p>Go中每个<strong>接口</strong>变量都对应一个pair(value, concrete type), value是这个变量的值，而concrete type是这个变量在runtime系统中看见的类型。反射就是检查<strong>接口</strong>变量内部pair的机制</p></blockquote><h3 id="Type-Value"><a href="#Type-Value" class="headerlink" title="Type &amp; Value"></a>Type &amp; Value</h3><p>reflect包提供了Type和Value两种核心类型，代表Go中的变量值和变量类型。可通过TypeOf和ValueOf方法获取变量的Type和Value。</p><p>reflect的TyepOf和ValueOf函数签名如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br></pre></td></tr></table></figure><p>这两函数先将传进来的变量转化为接口，再调用反射机制来实现对变量类型和值的查看</p><p>Type和Value也提供了一些方法：</p><ul><li>Type<ul><li>Kind() 对应的底层类型,返回Kind(本质是uint)</li><li>Elem() 返回元素的类型Type,参数必须是array,chan,map,pointer,slice等</li></ul></li><li>Value<ul><li>Kind()</li><li>Elem() 接口或指针对应的值</li><li>Type()</li><li>Interface() 以空接口的形式返回Value的值</li></ul></li></ul><h3 id="Field-Method"><a href="#Field-Method" class="headerlink" title="Field &amp; Method"></a>Field &amp; Method</h3><p>对于struct变量，可以通过NumField和NumMethod来遍历该结构体的字段和方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AnoStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Type <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ano := AnoStruct&#123;<span class="string">&quot;Ano&quot;</span>, <span class="string">&quot;AnoType&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">anoType := reflect.TypeOf(Ano)</span><br><span class="line">anoValue := reflect.ValueOf(Ano)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; anoType.NumField(); i++ &#123;</span><br><span class="line">    field := anoType.Field(i)</span><br><span class="line">    value := anoValue.Field(i)</span><br><span class="line">    fmt.Println(field.Name, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CanSet-Setxx"><a href="#CanSet-Setxx" class="headerlink" title="CanSet &amp; Setxx"></a>CanSet &amp; Setxx</h3><p>可以通过反射修改原变量</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须传入指针配合Elem()方法来修改原变量的值</span></span><br><span class="line">anoValue := reflect.ValueOf(&amp;Ano).Elem()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> anoValue.CanSet() &#123;</span><br><span class="line">    anoValue.SetInt(<span class="number">100</span>) <span class="comment">// 还有SetInt/SetFloat/SetString等方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p>可通过反射调用函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v* AnoStruct)</span></span> DoSomething(val <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">anoFunc := anoValue.MethodByName(<span class="string">&quot;DoSomething&quot;</span>)</span><br><span class="line">args = []reflect.Value&#123;reflect.ValueOf(<span class="string">&quot;Hello Reflect!&quot;</span>)&#125;</span><br><span class="line">anoFunc.Call(args)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>掌握Sort包的一些函数可以方便刷lc（不是</p><h3 id="sort-Interface"><a href="#sort-Interface" class="headerlink" title="sort.Interface"></a>sort.Interface</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="type">int</span>            <span class="comment">// 获取元素数量</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span> <span class="comment">// i，j是序列元素的指数。</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)        <span class="comment">// 交换元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sort-Sort"><a href="#sort-Sort" class="headerlink" title="sort.Sort"></a>sort.Sort</h3><p><code>sort.Sort</code>函数可对一个数组类型变量中的元素进行排序，且该数组类型变量需要实现<code>sort.Interface</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo/sort/Sort</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonsByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Person)</span></span>Len() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制升序降序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Person)</span></span>Less(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> demo[i].Age &lt; demo[j].Age <span class="comment">// 升序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Person)</span></span>Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    this[i], this[j] = this[j], this[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    demo := []Person&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Jame&quot;</span>, <span class="number">55</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">22</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">34</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Sort(PersonsByAge(demo))</span><br><span class="line">    fmt.Println(demo)</span><br><span class="line">    <span class="comment">// &#123;&quot;Bob&quot;, 22&#125;,&#123;&quot;Alice&quot;, 34&#125;, &#123;&quot;Jame&quot;, 55&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sort-Slice"><a href="#sort-Slice" class="headerlink" title="sort.Slice"></a>sort.Slice</h3><p><code>sort.Sort()</code>的使用方法过于麻烦，相比下使用<code>sort.Slice()</code>方法能更轻松实现数组的自定义排序。其第一个参数就是待排序数组，第二个参数就是指明排序方法的<code>less</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo/sort/Slice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    demo := []Person&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Jame&quot;</span>, <span class="number">55</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">22</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">34</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(demo, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> demo[i].Age &lt; demo[j].Age</span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(demo)</span><br><span class="line">    <span class="comment">// &#123;&quot;Bob&quot;, 22&#125;,&#123;&quot;Alice&quot;, 34&#125;, &#123;&quot;Jame&quot;, 55&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sort-Ints-sort-Float64s"><a href="#sort-Ints-sort-Float64s" class="headerlink" title="sort.Ints &#x2F; sort.Float64s"></a>sort.Ints &#x2F; sort.Float64s</h3><p>sort中有int和float数组的升序排序函数<code>sort.Ints(x []int)</code>和<code>sort.Float64(x []float64)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo/sort/Ints</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">demo := []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">67</span>,<span class="number">18</span>&#125;</span><br><span class="line">sort.Ints(demo)</span><br><span class="line">fmt.Println(demo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sort-Search"><a href="#sort-Search" class="headerlink" title="sort.Search"></a>sort.Search</h3><p><code>sort.Search(n int, f func(i int) bool) int</code>用于返回$[0, n)$中最小的能够满足参数f的索引值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo/sort/Seach</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">demo := []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">67</span>,<span class="number">18</span>&#125;</span><br><span class="line">    x := <span class="number">17</span></span><br><span class="line">    <span class="comment">// demo第一个大于等于x(17)的元素下标</span></span><br><span class="line">    ans := sort.Search(<span class="built_in">len</span>(data), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> demo[i] &gt;= x </span><br><span class="line">    &#125;)</span><br><span class="line">fmt.Println(ans, demo[ans], x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sort.SearchInts(x []int, target int)</code>,<code>sort.SearchFloat64s(x []float64, target float64)</code>和<code>sort.SearchStrings(x []string, target string)</code>作用与之类似，不展开描述。</p><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><p>container下包含了三个包：<code>list</code>、<code>heap</code>和<code>ring</code>，对应数据结构中的双向链表、堆、环形链表。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>实现源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">   next, prev *Element <span class="comment">// 前后指针</span></span><br><span class="line">   list *List <span class="comment">// 所属链表</span></span><br><span class="line">   Value any <span class="comment">// 值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">   root Element <span class="comment">// 哨兵元素</span></span><br><span class="line">   <span class="built_in">len</span>  <span class="type">int</span>     <span class="comment">// 链表元素个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点Element的Value的类型为空接口，故可以插入任意类型的数据。以下是<strong>List的方法</strong></p><ul><li>初始化：<ul><li><code>list.New() *List</code></li></ul></li><li>增: <ul><li><code>(s *list)PushFront(x any)</code></li><li><code>(s *list)PushBack(x any)</code></li><li><code>(s *list)PushFrontList(other *List)</code></li><li><code>(s *list)PushBackList(other *List)</code></li><li><code>(s *list)InsertAfter(v any, mark *Element)</code></li><li><code>(s *list)InsertBefore(v any, mark *Element)</code></li></ul></li><li>删<ul><li><code>(s *list)Remove(e *Element) any</code>, 返回被删除节点的值</li><li><code>(s *list)Init() *List</code>, 清空列表</li></ul></li><li>改<ul><li><code>(s *list)MoveToFront(e *Element)</code></li><li><code>(s *list)MoveToBack(e *Element)</code></li><li><code>(s *list)MoveBefore(e, mark *Element)</code></li><li><code>(s *list)MoveAfter(e, mark *Element)</code></li></ul></li><li>查<ul><li><code>(s *list)Back() *Element</code></li><li><code>(s *list)Front() *Element</code></li><li><code>(s *list)Len() int</code> O(1)</li></ul></li></ul><p>可通过<strong>Element</strong>的<code>Next() *Element</code>和<code>Prev() *Element</code>方法进行节点操作</p><h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><p>和sort包一样，heap也有一个Interface类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// 向末尾添加元素</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 从末尾删除元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有实现该接口的类型也能用<code>container/heap</code>包提供函数构建最大堆&#x2F;最小堆（由sort.Interface的Swap函数决定）。</p><p>常用的<strong>heap包提供的函数</strong>有：</p><ul><li>初始化<ul><li><code>Init()</code>, 即buildHeap()</li></ul></li><li>增<ul><li><code>Push(h Interface, v any)</code></li></ul></li><li>删<ul><li><code>Pop(h Interface)</code></li><li><code>Remove(h Interface, i int)</code>， 删除下标为i的元素</li></ul></li><li>改<ul><li><code>Fix(h Interface, i int)</code>，若下标i处被修改，可使用Fix函数创新从i处构造堆</li></ul></li></ul><h3 id="ring"><a href="#ring" class="headerlink" title="ring"></a>ring</h3><p>实现源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ring <span class="keyword">struct</span> &#123;</span><br><span class="line">   next, prev *Ring <span class="comment">// 前后指针</span></span><br><span class="line">   Value      any   <span class="comment">// 值，使用者自己设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ring的一些方法</p><ul><li>创建：<ul><li><code>New(i int)</code>，i为节点个数</li></ul></li><li>增：<ul><li><code>(s *Ring)Link(r *Ring) *Ring</code>, 当前环s与r拼接,使s的下个元素为r，并返回原本s的下个元素</li></ul></li><li>删：<ul><li><code>(s *Ring)Unlink(n int) *Ring</code>，删除从s.Next()开始的<code>n % s.Len()</code>个元素，返回被删除的环</li></ul></li><li>查：<ul><li><code>(s *Ring)Next() *Ring</code></li><li><code>(s *Ring)Prev() *Ring</code></li><li><code>(s *Ring)Len() int</code></li></ul></li><li>其他：<ul><li><code>(s *Ring)Do(f func(a any))</code>，对环的每个元素调用f函数</li><li><code>(s *Ring)Move(n int) *Ring</code>，s移动<code>|n|%s.Len()</code>个位置，<code>Move(1)==Next()</code>，<code>Move(-1)==Prev()</code></li></ul></li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Golang标准库下的缓冲区，可存储字节。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">buffer := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">buffer := bytes.NewBuffer(s []<span class="type">byte</span>)</span><br><span class="line">buffer := bytes.NewBufferString(s <span class="type">string</span>)</span><br></pre></td></tr></table></figure><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer.Write(s []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">buffer.WriteString(s <span class="type">string</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">buffer.WriteByte(b <span class="type">byte</span>) err <span class="type">error</span></span><br><span class="line">buffer.WriteRune(r <span class="type">rune</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">buffer.ReadFrom(f io.Reader) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h3 id="读出"><a href="#读出" class="headerlink" title="读出"></a>读出</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buffer.Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">buffer.Next(n <span class="type">int</span>) []<span class="type">byte</span></span><br><span class="line">buffer.ReadByte() (<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">buffer.ReadBytes(delimiter <span class="type">byte</span>) (line []<span class="type">byte</span>, err <span class="type">error</span>)</span><br><span class="line">buffer.ReadString(delimiter <span class="type">byte</span>) (line <span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line">buffer.WriteTo(w io.Writer) (n <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h2 id="Regexp"><a href="#Regexp" class="headerlink" title="Regexp"></a>Regexp</h2><p>正则表达式</p><h3 id="构建正则对象"><a href="#构建正则对象" class="headerlink" title="构建正则对象"></a>构建正则对象</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg := regexp.MustCompile(s <span class="type">string</span>) <span class="comment">// s为正则表达式</span></span><br></pre></td></tr></table></figure><h3 id="判定字符串是否符合正则表达式"><a href="#判定字符串是否符合正则表达式" class="headerlink" title="判定字符串是否符合正则表达式"></a>判定字符串是否符合正则表达式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag, err := regex.MatchString(reg <span class="type">string</span>, s <span class="type">string</span>)</span><br><span class="line">flag, err := reg.MatchString(s <span class="type">string</span>) <span class="comment">// reg为正则对象*Regexp</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Grammar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之主从复制</title>
      <link href="/2024/01/14/MySQL%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2024/01/14/MySQL%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主从复制指主数据库的DDL和DML操作通过二进制日志传送到从库服务器，在从库上对这些日志重新执行，从而使得从库和主库的数据保持同步</p><p>MySQL支持链状复制，一个主库可以向多个从库进行复制</p><p>作用：</p><ul><li>主库故障，可以快速切换到从库提供服务</li><li>实现读写分离，降低主库的访问压力</li><li>从主库执行备份，避免备份期间影响主库服务</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/./pics/image-20240829125228774.png" alt="image-20240829125228774"></p><ol><li>Master将DDL&#x2F;DML操作写入本地binlog</li><li>Slave的IO线程读取Master的binlog，并将其内容写入Slave本地的Relay log</li><li>Slave的SQL线程从中继日志Relay Log读取内容，并重做其中的时间，将改变反映到它自己的数据</li></ol><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h3><p>修改配置文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 要保证id在整个集群环境唯一</span><br><span class="line">server-id=<span class="number">1</span></span><br><span class="line"># <span class="number">1</span>表示只读，<span class="number">0</span>表示读写</span><br><span class="line">read-only=<span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>这里read-only仅针对普通用户，super用户仍有权限对数据库进行写操作；可以使用<code>super-read-only=1</code>限制super用户进行写操作</p></blockquote><p>重启服务后，主库还需要创建远程连接的账号，并赋予主从复制的权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;XXX&#x27;</span>@<span class="string">&#x27;XXX&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;XXX&#x27;</span></span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;XXX&#x27;</span>@<span class="string">&#x27;XXX&#x27;</span></span><br></pre></td></tr></table></figure><p>查看二进制日志坐标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><p>字段说明：</p><ul><li>file:从哪个文件开始推送日志文件</li><li>position:从哪个位置开始推送日志</li><li>binlog_ignore_db:指定不需要同步的数据库</li></ul><h3 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h3><p>修改配置文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server-id=xxx</span><br><span class="line">read-only=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>重启服务后，执行如下SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">8.0</span><span class="number">.23</span>之后</span><br><span class="line">CHANGE REPLICATION SOURCE <span class="keyword">TO</span> SOURCE_HOST<span class="operator">=</span><span class="string">&#x27;XXX&#x27;</span>, SOURCE_USER<span class="operator">=</span><span class="string">&#x27;XXX&#x27;</span>, SOURCE_PASSWORD<span class="operator">=</span><span class="string">&#x27;XXX&#x27;</span>, SOURCE_LOG_FILE<span class="operator">=</span><span class="string">&#x27;XXX&#x27;</span>, SOURCE_LOG_POS<span class="operator">=</span><span class="string">&#x27;XXX&#x27;</span>;</span><br><span class="line"># <span class="number">8.0</span><span class="number">.23</span>之前</span><br><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;XXX&#x27;</span>, MASTER_USER<span class="operator">=</span><span class="string">&#x27;XXX&#x27;</span>, MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;XXX&#x27;</span>, MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;XXX&#x27;</span>, MASTER_LOG_POS<span class="operator">=</span>XXX;</span><br></pre></td></tr></table></figure><p>启动主从复制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> replica; # <span class="number">8.0</span><span class="number">.22</span>之后</span><br><span class="line"><span class="keyword">start</span> slave; # <span class="number">8.0</span><span class="number">.23</span>之前</span><br></pre></td></tr></table></figure><p>查看主从复制状态(在从库执行)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> replica status;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Ops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web之Http基础</title>
      <link href="/2023/08/25/Http%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/08/25/Http%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议。</p><p>打开浏览器，随便访问一个网站，按F12打开开发者工具，点击<strong>网络&#x2F;Network</strong>,再次刷新网页，就可以看到你向这个网站服务器发送的HTTP请求数据包了。</p><p><img src="/images/http/image.png" alt="Alt text"></p><h2 id="HTTP请求格式"><a href="#HTTP请求格式" class="headerlink" title="HTTP请求格式"></a>HTTP请求格式</h2><p>HTTP请求包包含三个部分：请求行、请求头、请求体</p><h3 id="HTTP请求行"><a href="#HTTP请求行" class="headerlink" title="HTTP请求行"></a>HTTP请求行</h3><ul><li>请求行的内容<ul><li>方法类型</li><li>资源路径+查询参数</li><li>协议版本</li></ul></li></ul><p>直观地分析一个请求行<br><code>GET https://somewebsite.com/index.php?id=1 HTTP/1.1</code></p><ul><li>GET 是请求方式中的一种</li><li><code>https://somewebsite.com/index.php?id=1</code> 是URL，既资源路径+查询参数</li><li>HTTP&#x2F;1.1 协议版本</li></ul><blockquote><p><strong>请求方式</strong><br>只要有GET和POST两种方式，两者最直观的区别在于<strong>数据参数的位置</strong></p><ul><li>GET<br>数据参数往往直接写在URL的尾部，比如访问<code>https://somewebsite.com/index.php?usr=1&amp;pwd=1</code>时,就向目标网站传递了参数usr&#x3D;1和pwd&#x3D;1。</li><li>POST<br>数据参数往往写在请求体中<br>GET和POST的使用用途也往往不同，GET往往用来申请访问相关网页资源，POST往往用于向指定资源提交数据进行处理请求（例如提交表单或者上传文件）</li></ul></blockquote><h3 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h3><p>有一些常见的字段</p><ul><li>Host: 主机域名</li><li>User-Agent: 客户端相关信息</li><li>Accept：客户端想要的响应数据类型</li><li>Content-Type： 客户端告诉服务器实际发送的数据类型</li><li>X-Forwarded-For： 表示 HTTP 请求端真实 IP</li><li>Cookie: 某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据</li><li>Referer: 用于告知服务器用户的来源页面</li></ul><h3 id="HTTP请求体"><a href="#HTTP请求体" class="headerlink" title="HTTP请求体"></a>HTTP请求体</h3><p>客户端传给服务器的其他任意数据，POST方法下表单数据在此处<br>（使用GET方法的HTTP请求往往没有请求体）</p><h2 id="HTTP响应包"><a href="#HTTP响应包" class="headerlink" title="HTTP响应包"></a>HTTP响应包</h2><p>和请求包类似，由三个部分组成：响应行，响应头，响应体</p><h3 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h3><p>由协议版本，状态码，状态消息组成，比如<br><code>HTTP/1.1 200 OK</code></p><ul><li><p>协议版本  HTTP&#x2F;版本号</p></li><li><p>状态码:   XXX</p><ul><li>1xx 表示【临时响应】并需要请求者继续执行操作的状态代码</li><li>2xx 表示【成功】处理了请求的状态代码</li><li>3xx 表示要完成请求，需要进一步操作。通常，这些状态代码用来【重定向】</li><li>4xx 表示客户端错误–处理发生错误，责任在客户端</li><li>5xx 表示【服务器】在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错</li></ul><p>常见状态码</p><ul><li>200 客户端请求成功，即处理成功</li><li>302 只是所请求的资源已移动到由Location响应头给定的URL，浏览器会自动重新访问到这个页面</li><li>404 请求资源不存在，一般是URL输入有误，或者网站资源被删除了</li></ul></li><li><p>状态消息 描述状态码</p></li></ul><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>告知客户端的信息</p><ul><li>Date</li><li>Content-type</li></ul><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>服务器给客户端的数据内容，如HTML文件等。</p><h2 id="发送自定义HTTP请求"><a href="#发送自定义HTTP请求" class="headerlink" title="发送自定义HTTP请求"></a>发送自定义HTTP请求</h2><p>我们可以通过一些工具来发送自定义的HTTP请求</p><p>有些网站有配置防止爬虫爬取的技术，所以发送HTTP请求最好要设置HTTP请求头中的User-Agent等字段，让我们发送的请求“看上去”像是浏览器发送的。</p><h3 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h3><p>Windows和Linux命令行下都能用，是访问URL的计算机逻辑语言的工具。</p><ul><li>向目标网址发送请求</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://target.com </span><br></pre></td></tr></table></figure><ul><li>用指定方式发送请求</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://target.com -X GET</span><br><span class="line">curl http://target.com -X POST -d <span class="string">&quot;id=1&quot;</span></span><br></pre></td></tr></table></figure><p>当使用参数 -d，-X POST 可以省略，因为会隐式发起 POST 请求。</p><ul><li>设置HTTP请求头</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://target.com -H <span class="string">&quot;User-Agent:MyBrowser&quot;</span></span><br></pre></td></tr></table></figure><ul><li>设置表单数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://target.com -F <span class="string">&quot;username=admin&quot;</span> -F <span class="string">&quot;password=123456&quot;</span></span><br><span class="line">curl http://target.com -F <span class="string">&quot;file=@/path/to/file&quot;</span></span><br></pre></td></tr></table></figure><ul><li>设置cookie</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://target.com -b <span class="string">&quot;character=admin&quot;</span></span><br></pre></td></tr></table></figure><h3 id="HackBar浏览器插件"><a href="#HackBar浏览器插件" class="headerlink" title="HackBar浏览器插件"></a>HackBar浏览器插件</h3><p>下载名为HackBar的浏览器插件后，可以按F12在开发者工具中打开<br><img src="/images/http/image-1.png" alt="Alt text"><br>图形化界面使得自定义http请求很容易，最后点左上角EXECUTE发送</p><h3 id="Python的requests库"><a href="#Python的requests库" class="headerlink" title="Python的requests库"></a>Python的requests库</h3><p>可以写Python脚本来实现http数据包的发送</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">URL = <span class="string">&#x27;http://target.com&#x27;</span></span><br><span class="line"><span class="comment"># 参数、表单、文件头、cookie都以字典的形式作为函数参数</span></span><br><span class="line">param = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;12345&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;MyBrowser&#x27;</span></span><br><span class="line">    <span class="comment"># &#x27;Cookie&#x27;: &#x27;character=admin&#x27; #cookie可以在这里自定义</span></span><br><span class="line">&#125;</span><br><span class="line">cookie = &#123;</span><br><span class="line">    <span class="string">&#x27;character&#x27;</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># requests.get、requests.post方法分别用GET方法和POST方法发送http请求,返回response类</span></span><br><span class="line">response1 = requests.get(URL, params=param, headers=header, cookies=cookie)</span><br><span class="line">repsonse2 = requests.post(URL, data=data, headers=header,cookies=cookie)</span><br><span class="line"></span><br><span class="line"><span class="comment"># response类的常用属性有response.status_code（网站返回的状态码）,response.text（网站返回的响应体)</span></span><br><span class="line"><span class="built_in">print</span>(response1.text)</span><br><span class="line"><span class="built_in">print</span>(response2.text)</span><br></pre></td></tr></table></figure><h3 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h3><p>Burp Suite是一款强大的网络渗透工具，可以通过代理http请求包，修改相关字段，实现自定义数据包，可以自行搜索相关教程</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>现在有了上述基础知识，可以来点例题练练手</p><h3 id="攻防世界-Web-get-post"><a href="#攻防世界-Web-get-post" class="headerlink" title="攻防世界 Web get_post"></a>攻防世界 Web get_post</h3><p><img src="/images/http/image-2.png" alt="Alt text"></p><p>要求1： 请用GET方式提交一个名为a,值为1的变量<br>要求2： 请再以POST方式随便提交一个名为b,值为2的变量</p><p>用HackBar插件可以轻松秒杀<br><img src="/images/http/image-6.png" alt="Alt text"><br>EXECUTE后可得到flag</p><h3 id="攻防世界-Web-cookie"><a href="#攻防世界-Web-cookie" class="headerlink" title="攻防世界 Web cookie"></a>攻防世界 Web cookie</h3><p>题目描述：你知道什么是cookie吗？</p><p>打开开发者工具，查看cookie<br><img src="/images/http/image-4.png" alt="Alt text"><br>访问目录下的cookie.php试试<br>出现提示See the http response<br><img src="/images/http/image-5.png" alt="Alt text"><br>发现flag</p><h3 id="2023MoeCTF-Web-http"><a href="#2023MoeCTF-Web-http" class="headerlink" title="2023MoeCTF Web http"></a>2023MoeCTF Web http</h3><p>题目描述：用GET方法，完成五个任务</p><ol><li>use parameter: UwU&#x3D;u</li><li>post <strong>form</strong>: Luv&#x3D;u</li><li>use admin character</li><li>request from 127.0.0.1</li><li>use browser ‘MoeBrowser’</li></ol><p>关于这题我有写一篇详细的writeup<a href="#">我的writeup</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
